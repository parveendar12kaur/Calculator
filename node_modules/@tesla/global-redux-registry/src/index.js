import { createStore, applyMiddleware, compose, combineReducers } from 'redux'
import { createLogger } from 'redux-logger'
import { combineEpics, createEpicMiddleware } from 'redux-observable'
import thunkMiddleware from 'redux-thunk'

import _uniq from 'lodash/uniq'
import _get from 'lodash/get'
import _set from 'lodash/set'
import _isEmpty from 'lodash/isEmpty'
import _forOwn from 'lodash/forOwn'
import _difference from 'lodash/difference'
import _reduce from 'lodash/reduce'


// adding useful and common RxJs operators
// Importing just a few RxJs operators here that I think we will find useful. If we want others, 
// we can add/remove them over time.
// 
// It seems that in order for these operators to be used in epics inside the applications
// that register to the ReducerRegistry, they must be imported here 
// otherwise, they will not be available to operate on RxJs streams
// 
import 'rxjs/add/operator/do'
import 'rxjs/add/operator/find'
import 'rxjs/add/operator/isEmpty'
import 'rxjs/add/operator/catch'
import 'rxjs/add/operator/count'
import 'rxjs/add/operator/switch'
import 'rxjs/add/operator/delay'
import 'rxjs/add/operator/filter'
import 'rxjs/add/operator/map'
import 'rxjs/add/operator/mapTo'
import 'rxjs/add/operator/mergeMap'
import 'rxjs/add/operator/concatMap'
import 'rxjs/add/operator/min'
import 'rxjs/add/operator/max'
import 'rxjs/add/operator/pluck'
import 'rxjs/add/operator/reduce'
import 'rxjs/add/operator/groupBy'

import 'rxjs/add/observable/from'
import 'rxjs/add/observable/of'
import 'rxjs/add/observable/dom/ajax';


// Preserve initial state for not-yet-loaded reducers
// Redux will toss away state for yet-unknown reducers, so this creates a stub reducer to preserve data
function preserveState(reducers, initialState){

    const reducerNames = Object.keys(reducers);

    Object.keys(initialState).forEach(item => {
        if (reducerNames.indexOf(item) === -1) {
            reducers[item] = (state = null) => state
        }
    });

    return reducers;
}

const Shared = (state = {}, action) => {
    return Object.assign({}, state, {
        actions: {
            last: action
        }
    });
}


// ReducerRegistry
// Share Redux state among multiple applications
// @see http://nicolasgallagher.com/redux-modules-and-code-splitting/

class ReducerRegistry {

	constructor(props = {}){

		this.__emitChange = null
        this.__reducers = {Shared} 
        this.__initialState = {}
        this.__debug = props.debug;
        this.__callbacks = {}
        this.__epics = []
        this.__ready = false
        this.__requiredModules = []

        if(props.requiredModules && props.requiredModules.length) {
            this.__requiredModules = _uniq(props.requiredModules)
        }
	}

    // internal method that fires after all reducers have been registered
    __initStore() {

        let middleware = [thunkMiddleware]

        if(!_isEmpty(this.__epics)) {
            const epics = combineEpics(...this.__epics)
            const epicMiddleWare = createEpicMiddleware(epics)
            middleware.push(epicMiddleWare)
        }

        if (this.__debug) {
            // only enable logger during development
            middleware.push(createLogger())
        }        

        // Create the store, passing in parameters and any state overrides from injections or localStorage, etc
        this.__store = createStore(
            combineReducers(this.__reducers), 
            this.__initialState || {}, 
            compose( applyMiddleware( ...middleware ))
        )

        this.__ready = true

        _forOwn(this.__callbacks, (cb)=>{
            cb(this.__store);
        })
    }

    /**
     * Add callback to be fired when store has been initialized
     * @param  {Function} cb [description]
     * @return {[type]}      [description]
     */
    ready(cb) {
        this.__callbacks[Date.now()] = cb
    }

    /**
     * Subscribe to redux store
     * @param  {Function} listener
     * @return {ReducerRegistry}
     */
    subscribe(listener){
        if(this.__ready) {
            return this.__store.subscribe(listener)
        }
        else {
            setTimeout(()=>{
                // waiting a moment before attempting to subscribe again
                this.subscribe(listener)
            }, 20)
        }

        return this;
    }

    /**
     * Register application reducers and epics
     * @param  {[type]}   options.id           [description]
     * @param  {[type]}   options.reducer      [description]
     * @param  {Object}   options.initialState [description]
     * @param  {Boolean}  force                [description]
     * @param  {[type]}   epics}              [description]
     * @param  {Function} cb                   [description]
     * @return {[type]}                        [description]
     */
	register({id, reducers, initialState = {}, force = false, epics}, cb){

        if(!id) {
            console.error('required id param is undefined');
            return            
        }

		if(this.__reducers[id] && !force) {
            console.warn(`A reducer named ${id} has already been injected.`);
            return
 		}


        this.__callbacks[id] = cb
 		this.__reducers = { ...this.__reducers, ...reducers }

        if(initialState) {
            this.__initialState = { ...this.__initialState, ...initialState }
        }

        if(epics) {
            this.__epics = [...this.__epics, ...epics ]    
        }

        const isReady = _difference(this.__requiredModules, Object.keys(this.__callbacks)).length === 0;

        if(isReady) {
            this.__initStore()
        }
	}


    /**
     * Add required module id
     * @param {String} id [description]
     */
    addRequired(id){
        if(id) {
            this.__requiredModules = _uniq(this.__requiredModules.concat([id]))
        }
        else {
            console.error('addRequired: id is a required parameter')
        }
        return this
    }

    /**
     * Return Redux Store
     * @return {Redux Store} [description]
     */
    getStore() {
        return this.__store
    }

    /**
     * shortcut method to returns specific reducer from store
     * @param  {String} reducerName
     * @return {Object}
     */
    getState(reducerName) {
        if(reducerName) {
            return this.__store.getState()[reducerName]
        }
        else {
            return this.__store.getState()
        }
    }

    /**
     * Return all reducers (not sure why you'd need to call this)
     */
    getReducers(){
         return { ...this.__reducers }
    }    

}


const requiredModules = _get(window, 'tesla.registry.requiredModules');
const reducerRegistry = new ReducerRegistry({debug: true, requiredModules});

_set(window, 'tesla.reducerRegistry', reducerRegistry)

 export default reducerRegistry;
