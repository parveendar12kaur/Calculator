/* jshint esversion: 6 */
/**
 * Scripts for the marketing carousel component. Handles carousel item selection upon click as well as
 * auto-transitions between marketing carousel items based on defined intervals for images and upon completion
 * for videos. Class pattern replicates the class patterns for AEM JS Components.
 *
 */

/**
 * @class Carousel
 *
 * Holds component states and events for the marketing carousel component. The marketing
 * carousel components consists of a top level class, tsla-carousel-container, with child
 * elements tsla-carousel-header, tsla-carousel-navigation, and tsla-carousel-assets.
 *
 * The component markup structure can be visualized as below:
 *
 * .tsla-carousel-container
 *   .tsla-carousel-header
 *   .tsla-carousel-navigation
 *     .tsla-carousel-items
 *       .tsla-carousel-item
 *   .tsla-carousel-assets
 *     .tsla-carousel-asset
 *
 * Component State
 * @param {Element} active - Actively selected index.
 * @param {Element} previous - Previously selected index.
 * @param {Array} items - Carousel item elements.
 * @param {Array} assets - Carousel assets.
 * @param {Number} timeout - Holds timeout for the autotransition.
 */
class Carousel {
  constructor(element) {
    this.element = element;
  }

  /**
   * Initialize state and listeners for the carousel component.
   */
  init() {
    const {
      element,
    } = this;

    // Set element state.
    this.state = {
      active: 0,
      previous: 0,
      items: [...element.querySelectorAll('.tsla-carousel-item')],
      assets: [...element.querySelectorAll('.tsla-carousel-asset')],
      timeout: null,
    };

    // Bind functions.
    this.increment = this.incrementItem.bind(this);
    this.decrement = this.decrementItem.bind(this);

    // Set active element to first item if an element with .is-active class does not exist.
    const initialActive = element.querySelector('.tsla-carousel-item.tsla-carousel-item--active');
    const initialActiveIndex = initialActive ? this.state.items.indexOf(initialActive) : 0;

    this.transitionItem(initialActiveIndex);
    this.startAutoTransition();

    // Transition to carousel item upon click.
    this.state.items.forEach((item, index) => {
      item.addEventListener('click', this.transitionItem.bind(this, index));
    });

    const prevArrow = element.querySelector('[data-arrow="tsla-carousel-arrow--prev"]');
    const nextArrow = element.querySelector('[data-arrow="tsla-carousel-arrow--next"]');

    // Bind clicks on arrows
    if (prevArrow) {
      prevArrow.addEventListener('click', () => this.decrementItem());

      // Pause on mouseover of carousel arrow
      prevArrow.addEventListener('mouseover', () => this.stopAutoTransition());

      // Unpause on hover of carousel arrow
      nextArrow.addEventListener('mouseout', () => this.startAutoTransition());
    }

    if (nextArrow) {
      nextArrow.addEventListener('click', () => this.incrementItem());

      // Pause on mouseover of carousel arrow
      nextArrow.addEventListener('mouseover', () => this.stopAutoTransition());

      // Unpause on mouseout of carousel arrow
      nextArrow.addEventListener('mouseout', () => this.startAutoTransition());
    }

    // Pause on mouseover of carousel container
    element.addEventListener('mouseover', () => this.stopAutoTransition());

    // Unpause on mouseout of carousel container
    element.addEventListener('mouseout', () => this.startAutoTransition());
  }

  /**
   * Transitions from one carousel item to the next.
   *
   * @param {Element} next - Next carousel item DOM element.
   */
  transitionItem(next) {
    const {
      active,
      items,
      assets,
    } = this.state;

    // Only transition if the clicked element is different from current active element.
    if (next === active) return;

    // Remove active class from current active item / asset and add to the next item / asset.
    items[active].classList.remove('tsla-carousel-item--active');
    assets[active].classList.remove('tsla-carousel-asset--active');

    items[next].classList.add('tsla-carousel-item--active');
    assets[next].classList.add('tsla-carousel-asset--active');

    // Update active item border box.
    items[active].parentElement.style.setProperty('--tsla-carousel-slide', next);

    const itemWidth = window.getComputedStyle(this.element).getPropertyValue('--tsla-base-spacer').trim();
    const itemWidthMultiplier = 20;
    const itemBorder = window.getComputedStyle(this.element).getPropertyValue('--tsla-carousel-item-border_width').trim();
    const boxWidth = `${itemWidth} * ${itemWidthMultiplier}`;

    if (next === 0) {
      items[active].parentElement.style.setProperty('--tsla-carousel-boxleft', '0');
    } else if (next === (items.length - 1)) {
      items[active].parentElement.style.setProperty('--tsla-carousel-boxleft', `calc(${this.element.offsetWidth}px - ${boxWidth})`);
    } else {
      items[active].parentElement.style.setProperty('--tsla-carousel-boxleft', `calc(${this.element.offsetWidth}px - (${boxWidth} * 1.5))`);
      // items[active].parentElement.style.setProperty('--tsla-carousel-boxleft', `calc(${this.element.offsetWidth}px - (${boxWidth}) / 2)`);
    }

    // Update state.
    this.state.previous = this.state.active;
    this.state.active = next;

    // Restart timeout listeners.
    this.startAutoTransition();
  }

  /**
   * Sets up listeners to automatically transitions to the next slide.
   *
   * @param {Number} timeout - Time between slide transitions in milliseconds.
   * @param {String} variant - Transition variant. Includes 'timeout', '' and ''.
   */
  startAutoTransition(timeout = 3000) {
    // Prevent previously queued up transition.
    this.stopAutoTransition();

    const currentAsset = this.state.assets[this.state.active];

    // If transitioning to a video element, set to transition to next element when the video ends.
    // Otherwise, set a timeout.
    if (currentAsset && currentAsset.tagName === 'VIDEO') {
      currentAsset.currentTime = 0;
      currentAsset.addEventListener('ended', this.increment);
      if (currentAsset.paused) currentAsset.load();
    } else {
      this.state.autoTransitionTimeout = setTimeout(this.increment, timeout);
    }
  }

  /**
   * Stops auto transition for carousel items.
   */
  stopAutoTransition() {
    // Clear next timeout if it exists.
    if (this.state.autoTransitionTimeout) clearTimeout(this.state.autoTransitionTimeout);
    this.state.autoTransitionTimeout = null;

    // Remove video 'ended' event listener transition if the previous item was a video.
    const item = this.state.assets[this.state.previous];
    if (item && item.tagName === 'VIDEO') {
      item.removeEventListener('ended', this.increment);
      item.pause();
    }
  }

  /**
   * Increments active item by 1, or returns to beginning if there are no more items.
   */
  incrementItem() {
    const newState = (this.state.active + 1) % this.state.items.length;
    this.transitionItem(newState);
  }

  /**
   * Decrements active item by 1, or returns to end if there at the beginning.
   */
  decrementItem() {
    let newState = this.state.active - 1;
    if (newState < 0) newState = this.state.items.length - 1;
    this.transitionItem(newState);
  }
}


/**
 * Bind marketing carousel event listeners upon DOM load.
 */
document.addEventListener('DOMContentLoaded', () => {
  // Get all marketing carousels.
  const tslaCarousels = [...document.querySelectorAll('.tsla-carousel-container')];

  // Initialize each marketing carousel.
  tslaCarousels.map((element) => {
    const tslaCarousel = new Carousel(element);
    return tslaCarousel.init();
  });
});
