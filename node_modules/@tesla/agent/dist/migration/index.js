'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var without = require('lodash/without');
var TYPES = require('../utils/types');
var Configuration = require('../utils/configuration');
var Lexicon = require('../utils/lexicon');
var Validator = require('../validator');

module.exports = {
    migrate: migrate,
    transformMigrationLexiconForDowngrade: transformMigrationLexiconForDowngrade
};

/* eslint-disable no-param-reassign */
function migrate() {
    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var sourceLexicon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var targetLexicon = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var sourceOptionList = Configuration.getOptionList(configuration);
    var normalizedSourceLexicon = Lexicon.normalizeLexicon(sourceLexicon);
    var normalizedTargetLexicon = Lexicon.normalizeLexicon(targetLexicon);
    var validationResult = Validator.validateRules(sourceOptionList, normalizedSourceLexicon);
    if (validationResult.success) {
        var migrationType = getMigrationType(normalizedSourceLexicon, normalizedTargetLexicon);
        if (TYPES.MIGRATION_LEXICON_CROSS_COUNTRY === migrationType) {
            return {
                success: false,
                message: 'We can\'t handle cross country migration now.',
                code: TYPES.MIGRATION_RESULT_TYPE_UNSUPPORTED_MIGRATION
            };
        }
        var migratedOptionList = [];
        var migrationsInSourceLexicon = normalizedSourceLexicon.metadata.migrations || [];
        var migrationsInTargetLexicon = normalizedTargetLexicon.metadata.migrations || [];
        switch (migrationType) {
            case TYPES.MIGRATION_LEXICON_DIRECTION_UPGRADE:
                migratedOptionList = upgrade(sourceOptionList, migrationsInTargetLexicon.slice(migrationsInSourceLexicon.length), normalizedTargetLexicon);
                break;
            case TYPES.MIGRATION_LEXICON_DIRECTION_DOWNGRADE:
                migratedOptionList = downgrade(sourceOptionList, migrationsInSourceLexicon.slice(migrationsInTargetLexicon.length), normalizedTargetLexicon);
                break;
        }
        var configurationAfterMigration = migratedOptionList.reduce(function (options, option) {
            options = Validator.toggleOption({
                lexicon: normalizedTargetLexicon,
                actions: TYPES.SET_RULE_ACTION,
                options: options,
                option: option
            });
            return options;
        }, normalizedTargetLexicon.base_configuration);
        return {
            success: true,
            data: configurationAfterMigration
        };
    }
    validationResult.code = TYPES.MIGRATION_RESULT_TYPE_INVALID_CONFIGURATION;
    return validationResult;
}

function upgrade(sourceOptionList, migrationLexicon, targetLexicon) {
    var optionList = sourceOptionList.slice(0);
    migrationLexicon.forEach(function (migrationItem) {
        var normalizedMigrationItem = Lexicon.normalizeLexicon(migrationItem);
        Object.keys(normalizedMigrationItem.options).forEach(function (migrationOptionCode) {
            if (optionList.indexOf(migrationOptionCode) > -1) {
                var action = targetLexicon.options[migrationOptionCode] ? TYPES.SET_RULE_ACTION : TYPES.UNSET_RULE_ACTION;
                var rulesType = action === TYPES.SET_RULE_ACTION ? TYPES.SET_OPTION_TRIGGERD_RULES : TYPES.UNSET_OPTION_TRIGGERD_RULES;
                optionList = migrationOption(optionList, normalizedMigrationItem.options[migrationOptionCode][rulesType]);
            }
        });
    });
    return optionList;
}

function downgrade(sourceOptionList, migrationLexicon, targetLexicon) {
    var optionList = sourceOptionList.slice(0);
    var downgradeMigrations = transformMigrationLexiconForDowngrade(migrationLexicon);
    downgradeMigrations.forEach(function (migrationItem) {
        var normalizedMigrationItem = Lexicon.normalizeLexicon(migrationItem);
        Object.keys(normalizedMigrationItem.options).forEach(function (migrationOptionCode) {
            if (optionList.indexOf(migrationOptionCode) > -1) {
                var action = targetLexicon.options[migrationOptionCode] ? TYPES.SET_RULE_ACTION : TYPES.UNSET_RULE_ACTION;
                var rulesType = action === TYPES.SET_RULE_ACTION ? TYPES.SET_OPTION_TRIGGERD_RULES : TYPES.UNSET_OPTION_TRIGGERD_RULES;
                optionList = migrationOption(optionList, normalizedMigrationItem.options[migrationOptionCode][rulesType]);
            }
        });
    });
    return optionList;
}

function transformMigrationLexiconForDowngrade(migrationLexicon) {
    return migrationLexicon.reverse().map(function (migrationItem) {
        var normalizedMigrationItem = Lexicon.normalizeLexicon(migrationItem);
        var transformedRules = Object.keys(normalizedMigrationItem.options).reduce(function (rules, migrationOptionCode) {
            var setOptionRules = normalizedMigrationItem.options[migrationOptionCode][TYPES.SET_OPTION_TRIGGERD_RULES];
            var unsetOptionRules = normalizedMigrationItem.options[migrationOptionCode][TYPES.UNSET_OPTION_TRIGGERD_RULES];
            if (unsetOptionRules.length > 0) {
                // Build the rules dynamically with the new option code we set in new lexicon
                var setRulesInUnsetOptionRules = unsetOptionRules.filter(function (rule) {
                    return rule.action === TYPES.SET_RULE_ACTION;
                });
                var reversedUnsetRules = unsetOptionRules.reduce(function (reversedRules, rule) {
                    if (rule.action === TYPES.UNSET_RULE_ACTION) {
                        reversedRules.push(reverseRuleAction(rule));
                    }
                    return reversedRules;
                }, []);
                setRulesInUnsetOptionRules.forEach(function (rule) {
                    var reversedSetRule = [reverseRuleAction(rule)];
                    rules[rule.target] = _defineProperty({}, TYPES.UNSET_OPTION_TRIGGERD_RULES, reversedSetRule.concat(reversedUnsetRules));
                });
            } else {
                setOptionRules = setOptionRules.map(function (rule) {
                    return reverseRuleAction(rule);
                });
                rules[migrationOptionCode] = _defineProperty({}, TYPES.SET_OPTION_TRIGGERD_RULES, setOptionRules);
            }
            return rules;
        }, {});
        return {
            options: transformedRules
        };
    });
}

function reverseRuleAction(rule) {
    return Object.assign({}, rule, { action: rule.action === TYPES.SET_RULE_ACTION ? TYPES.UNSET_RULE_ACTION : TYPES.SET_RULE_ACTION });
}

function getMigrationType(sourceLexicon, targetLexicon) {
    if (sourceLexicon.market === targetLexicon.market) {
        return getMigrationDirection(sourceLexicon, targetLexicon);
    }
    return TYPES.MIGRATION_LEXICON_CROSS_COUNTRY;
}

function getMigrationDirection(sourceLexicon, targetLexicon) {
    var sourceLexiconEffectiveTimeStamp = +new Date(sourceLexicon.effective_date);
    var targetLexiconEffectiveTimeStamp = +new Date(targetLexicon.effective_date);
    return sourceLexiconEffectiveTimeStamp <= targetLexiconEffectiveTimeStamp ? TYPES.MIGRATION_LEXICON_DIRECTION_UPGRADE : TYPES.MIGRATION_LEXICON_DIRECTION_DOWNGRADE;
}

function migrationOption() {
    var optionList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var optionRules = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    var options = optionList.slice(0);
    // See the definations from https://confluence.teslamotors.com/display/OC/Understanding+the+Options+Warehouse+Data
    if (optionRules && optionRules.length) {
        optionRules.forEach(function (optionRule) {
            var action = optionRule.action,
                target = optionRule.target,
                operator = optionRule.operator,
                operatorConditions = optionRule.operatorConditions,
                conditionCode = optionRule.conditionCode,
                conditionState = optionRule.conditionState;

            var applyRuleFlag = true;
            if (conditionCode && conditionState) {
                if (TYPES.UNSET_RULE_ACTION === conditionState && options.indexOf(conditionCode) === -1) {
                    applyRuleFlag = true;
                } else if (TYPES.SET_RULE_ACTION === conditionState && options.indexOf(conditionCode) > -1) {
                    applyRuleFlag = true;
                } else {
                    applyRuleFlag = false;
                }
            }
            if (operator) {
                if (TYPES.RULE_OPERATOR_AND === operator) {
                    applyRuleFlag = true;
                    operatorConditions.forEach(function (_ref) {
                        var conditionCode = _ref.conditionCode,
                            conditionState = _ref.conditionState;

                        if (conditionState === TYPES.UNSET_RULE_ACTION && options.indexOf(conditionCode) > -1) {
                            applyRuleFlag = false;
                        } else if (conditionState === TYPES.SET_RULE_ACTION && options.indexOf(conditionCode) === -1) {
                            applyRuleFlag = false;
                        }
                    });
                } else if (TYPES.RULE_OPERATOR_OR === operator) {
                    applyRuleFlag = false;
                    operatorConditions.forEach(function (_ref2) {
                        var conditionCode = _ref2.conditionCode,
                            conditionState = _ref2.conditionState;

                        if (conditionState === TYPES.UNSET_RULE_ACTION && options.indexOf(conditionCode) === -1) {
                            applyRuleFlag = true;
                        } else if (conditionState === TYPES.SET_RULE_ACTION && options.indexOf(conditionCode) > -1) {
                            applyRuleFlag = true;
                        }
                    });
                }
            }
            if (applyRuleFlag) {
                if (action === TYPES.SET_RULE_ACTION && options.indexOf(target) === -1) {
                    options.push(target);
                }
                if (action === TYPES.UNSET_RULE_ACTION && options.indexOf(target) > -1) {
                    options = without(options, target);
                }
            }
        });
    }
    return options;
}