'use strict';

var difference = require('lodash/difference');
var without = require('lodash/without');
var uniq = require('lodash/uniq');
var Rx = require('rxjs/Rx');

var Configuration = require('../utils/configuration');
var TYPES = require('../utils/types');
var Lexicon = require('../utils/lexicon');
var Utils = require('../utils/index');

module.exports = {
    validate: validate,
    validatePromise: validatePromise,
    validateObservable$: validateObservable$,
    validateRules: validateRules,
    validateRulesAndPrice: validateRulesAndPrice,
    validateRulesAndPriceWithSubtotal: validateRulesAndPriceWithSubtotal,
    validatePrice: validatePrice,
    validatePriceWithSubtotal: validatePriceWithSubtotal,
    validateDuplication: validateDuplication,
    validateRequired: validateRequired,
    validateOptionSetRules: validateOptionSetRules,
    validateArbitraryOptions: validateArbitraryOptions,
    toggleOption: toggleOption,
    toggleOptions: toggleOptions,
    toggleOptionByGroup: toggleOptionByGroup,
    getOptionPrice: getOptionPrice
};

var LEXICON_WITH_PRICES = [TYPES.VALIDATION_TYPE_MARKETING, TYPES.VALIDATION_TYPE_MARKETING_BY_VMID, TYPES.VALIDATION_TYPE_MARKETING_WITH_CUSTOM_PRICING, TYPES.VALIDATION_TYPE_MARKETING_BY_VMID_WITH_CUSTOM_PRICING, TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING, TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_BY_VMID, TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_WITH_CUSTOM_PRICING, TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_BY_VMID_WITH_CUSTOM_PRICING];

var CUSTOMIZE_PRICING_VALIDATION_TYPES = [TYPES.VALIDATION_TYPE_MARKETING_WITH_CUSTOM_PRICING, TYPES.VALIDATION_TYPE_MARKETING_BY_VMID_WITH_CUSTOM_PRICING, TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_WITH_CUSTOM_PRICING, TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_BY_VMID_WITH_CUSTOM_PRICING];

function validate() {
    var configurations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var validationCallback = arguments[1];
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TYPES.VALIDATION_TYPE_MARKETING;

    validateObservable$(configurations, type).subscribe(function (result) {
        if (validationCallback) {
            validationCallback(result);
        }
    });
}

function validatePromise() {
    var configurations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TYPES.VALIDATION_TYPE_MARKETING;

    return validateObservable$(configurations, type).toPromise();
}

function validateObservable$() {
    var configurations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TYPES.VALIDATION_TYPE_MARKETING;

    var normalizedConfigurations = Utils.normalizeInput(configurations);
    return Rx.Observable.from(normalizedConfigurations).concatMap(function (configuration) {
        return validateConfigurationObservable$(configuration, type);
    }).toArray().map(function (result) {
        return Utils.normalizeOutput(configurations, result);
    });
}

function validateConfigurationObservable$() {
    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TYPES.VALIDATION_TYPE_MARKETING;

    return Lexicon.getLexicon$(configuration, type).map(function (lexicon) {
        return validateRulesAndPrice(configuration, type, lexicon);
    }).map(function (result) {
        return Utils.httpExceptionTransform(result);
    });
}

function validateRulesAndPrice(configuration, type, lexicon) {
    var sourceOptionList = Configuration.getOptionList(configuration);
    var groupAndRulesValidationResult = validateRules(sourceOptionList, lexicon);
    if (!groupAndRulesValidationResult.success || LEXICON_WITH_PRICES.indexOf(type) === -1) {
        return groupAndRulesValidationResult;
    }
    return validatePrice(configuration.options, lexicon, type);
}

function validateRulesAndPriceWithSubtotal(configuration, type, lexicon) {
    var sourceOptionList = Configuration.getOptionList(configuration);
    var groupAndRulesValidationResult = validateRules(sourceOptionList, lexicon);
    if (!groupAndRulesValidationResult.success || LEXICON_WITH_PRICES.indexOf(type) === -1) {
        return groupAndRulesValidationResult;
    }
    var optionPriceValidationResult = validatePrice(configuration.options, lexicon, type);
    if (!optionPriceValidationResult.success) {
        return optionPriceValidationResult;
    }
    return validateSubtotal(configuration);
}

function validateRules(sourceOptionList, lexicon) {
    if (lexicon === TYPES.EXCEPTION_HTTP_REQUEST) {
        return Rx.Observable.of(lexicon);
    }
    var transformedLexicon = Lexicon.normalizeLexicon(lexicon);

    var arbitraryValidationResult = validateArbitraryOptions(sourceOptionList, transformedLexicon);
    if (!arbitraryValidationResult.success) {
        return arbitraryValidationResult;
    }
    var groupOfOptions = Lexicon.getGroupOfOptions(sourceOptionList, transformedLexicon).slice().sort();
    var duplicationValidationResult = validateDuplication(groupOfOptions, transformedLexicon);
    if (!duplicationValidationResult.success) {
        return duplicationValidationResult;
    }

    var requiredValidationResult = validateRequired(groupOfOptions, transformedLexicon);
    if (!requiredValidationResult.success) {
        return requiredValidationResult;
    }

    return validateOptionSetRules(sourceOptionList, transformedLexicon);
}

function validateDuplication(groupOfOptions, lexicon) {
    var exclusiveGroupInLexicon = Lexicon.getExclusiveGroups(lexicon);
    var exclusiveGroupOfOptions = groupOfOptions.filter(function (group) {
        return exclusiveGroupInLexicon.indexOf(group) > -1;
    });
    var duplicatedGroups = exclusiveGroupOfOptions.filter(function (item, index) {
        return exclusiveGroupOfOptions[index] === exclusiveGroupOfOptions[index + 1] || exclusiveGroupOfOptions[index] === exclusiveGroupOfOptions[index - 1];
    });
    var validationResult = exclusiveGroupOfOptions.length === uniq(exclusiveGroupOfOptions).length;
    return {
        success: validationResult,
        message: validationResult ? 'success' : 'Duplicated options of group [' + uniq(duplicatedGroups).join(', ') + ']',
        code: validationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : TYPES.VALIDATION_RESULT_TYPE_CONTAINS_DUPLICATED_OPTIONS
    };
}

function validateRequired(groupOfOptions, lexicon) {
    var requiredGroupInLexicon = Lexicon.getRequiredGroups(lexicon);
    var missingRequiredGroups = difference(requiredGroupInLexicon, groupOfOptions);
    var validationResult = missingRequiredGroups.length === 0;
    return {
        success: validationResult,
        message: validationResult ? 'success' : 'Missing required group [' + missingRequiredGroups.join(', ') + ']',
        code: validationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : TYPES.VALIDATION_RESULT_TYPE_MISSING_REQUIRED_OPTIONS
    };
}

function validateArbitraryOptions(sourceOptions, lexicon) {
    var optionsInLexicon = Object.keys(lexicon.options);
    var arbitraryOptions = difference(sourceOptions, optionsInLexicon);
    var validationResult = !arbitraryOptions.length;
    return {
        success: validationResult,
        message: validationResult ? 'success' : 'Some option codes doesn\'t exist in lexicon [' + arbitraryOptions.join(', ') + ']',
        code: validationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : TYPES.VALIDATION_RESULT_TYPE_CONTAINS_ARBITRARY_OPTIONS
    };
}

function getOptionPrice(optionCode, lexicon) {
    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TYPES.OCW_PRICE_DEFAULT_CONTEXT;
    var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TYPES.OCW_PRICE_TYPE_BASE;

    var option = lexicon.options[optionCode];
    var price = 0;
    if (option) {
        if (option.pricing) {
            var basePriceItem = option.pricing.filter(function (pricing) {
                return pricing.context === context && pricing.type === type;
            });
            if (basePriceItem && basePriceItem[0]) {
                price = basePriceItem[0].value;
            }
        } else {
            price = option.price;
        }
    }
    return price;
}

function validatePrice() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var lexicon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TYPES.VALIDATION_TYPE_MARKETING;

    var mismatchPriceOptions = [];
    options.forEach(function (_ref) {
        var code = _ref.code,
            price = _ref.price,
            isCustomPricing = _ref.isCustomPricing;

        var priceFromLexicon = getOptionPrice(code, lexicon);
        var validateCustomizePricing = CUSTOMIZE_PRICING_VALIDATION_TYPES.indexOf(type) > -1;
        if (price !== priceFromLexicon && !(validateCustomizePricing && isCustomPricing)) {
            mismatchPriceOptions.push({
                code: code,
                price: price,
                priceFromLexicon: priceFromLexicon
            });
        }
    });
    var validationResult = !mismatchPriceOptions.length;
    return {
        success: validationResult,
        message: validationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : 'Price in options are different from lexicon ' + JSON.stringify(mismatchPriceOptions),
        code: validationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : TYPES.VALIDATION_RESULT_TYPE_PRICE_TAMPERING
    };
}

function validatePriceWithSubtotal(configuration) {
    var lexicon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TYPES.VALIDATION_TYPE_MARKETING;

    var mismatchPriceOptions = [];
    configuration.options.forEach(function (_ref2) {
        var code = _ref2.code,
            price = _ref2.price,
            isCustomPricing = _ref2.isCustomPricing;

        var priceFromLexicon = getOptionPrice(code, lexicon);
        var validateCustomizePricing = CUSTOMIZE_PRICING_VALIDATION_TYPES.indexOf(type) > -1;
        if (price !== priceFromLexicon && !(validateCustomizePricing && isCustomPricing)) {
            mismatchPriceOptions.push({
                code: code,
                price: price,
                priceFromLexicon: priceFromLexicon
            });
        }
    });
    var optionPriceValidationResult = !mismatchPriceOptions.length;
    if (!optionPriceValidationResult) {
        return {
            success: optionPriceValidationResult,
            message: optionPriceValidationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : 'Price in options are different from lexicon ' + JSON.stringify(mismatchPriceOptions),
            code: optionPriceValidationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : TYPES.VALIDATION_RESULT_TYPE_PRICE_TAMPERING
        };
    }
    return validateSubtotal(configuration);
}

function validateSubtotal(configuration) {
    var calculatedSubtotal = configuration.options.reduce(function (total, option) {
        return total + parseFloat(option.price, 10);
    }, 0);
    var validationResult = parseFloat(configuration.subtotal, 10) === calculatedSubtotal;
    return {
        success: validationResult,
        message: validationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : 'Subtotal should be ' + calculatedSubtotal,
        code: validationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : TYPES.VALIDATION_RESULT_TYPE_PRICE_TAMPERING
    };
}

function validateOptionSetRules(sourceOptions, lexicon) {
    var optionListFromLexiconRules = [];
    sourceOptions.forEach(function (optionToSet) {
        optionListFromLexiconRules = toggleOption({
            options: optionListFromLexiconRules,
            option: optionToSet,
            action: TYPES.SET_RULE_ACTION,
            lexicon: lexicon
        });
    });
    var optionsDifference = [difference(sourceOptions, optionListFromLexiconRules), difference(optionListFromLexiconRules, sourceOptions)];
    var validationResult = !(optionsDifference[0].length || optionsDifference[1].length);
    return {
        success: validationResult,
        message: validationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : 'Conflicts occurred in options ' + optionsDifference[0].join(', ') + ' or ' + optionsDifference[1].join(', '),
        code: validationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : TYPES.VALIDATION_RESULT_TYPE_CONFLICT_WITH_LEXICON_RULES
    };
}

function toggleOption() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$options = _ref3.options,
        options = _ref3$options === undefined ? [] : _ref3$options,
        _ref3$option = _ref3.option,
        option = _ref3$option === undefined ? '' : _ref3$option,
        _ref3$lexicon = _ref3.lexicon,
        lexicon = _ref3$lexicon === undefined ? {} : _ref3$lexicon,
        _ref3$action = _ref3.action,
        action = _ref3$action === undefined ? TYPES.SET_RULE_ACTION : _ref3$action;

    var sourceOptions = options.slice(0);
    var transformedLexicon = Lexicon.normalizeLexicon(lexicon);
    return toggleOptionRecursively({
        options: sourceOptions,
        lexicon: transformedLexicon,
        action: action,
        option: option
    });
}

/*
 * This method will help the consumer to make the decision, we will set or unset the option
 * Assume the default action is set, only if the option already exists in options and the group of the option is neither exclusive nor required, we will switch the action to unset automatically.
 */

function toggleOptionByGroup(_ref4) {
    var _ref4$options = _ref4.options,
        options = _ref4$options === undefined ? [] : _ref4$options,
        _ref4$option = _ref4.option,
        option = _ref4$option === undefined ? '' : _ref4$option,
        _ref4$lexicon = _ref4.lexicon,
        lexicon = _ref4$lexicon === undefined ? {} : _ref4$lexicon;

    var sourceOptions = options.slice(0);
    var transformedLexicon = Lexicon.normalizeLexicon(lexicon);
    var optionInLexicon = transformedLexicon.options[option];
    if (optionInLexicon) {
        var groupOfOption = transformedLexicon.options[option].group;
        var groupInLexicon = transformedLexicon.groups.find(function (group) {
            return group.code === groupOfOption;
        });
        if (groupInLexicon) {
            var action = TYPES.SET_RULE_ACTION;
            var optionInSourceOptions = sourceOptions.indexOf(option) > -1;
            if (optionInSourceOptions && !groupInLexicon.exclusive && !groupInLexicon.required) {
                action = TYPES.UNSET_RULE_ACTION;
            }
            return toggleOptionRecursively({
                options: sourceOptions,
                lexicon: transformedLexicon,
                action: action,
                option: option
            });
        }
    }
    return sourceOptions;
}

/* eslint-disable no-param-reassign */
function toggleOptions() {
    var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref5$options = _ref5.options,
        options = _ref5$options === undefined ? [] : _ref5$options,
        _ref5$lexicon = _ref5.lexicon,
        lexicon = _ref5$lexicon === undefined ? {} : _ref5$lexicon,
        _ref5$actions = _ref5.actions,
        actions = _ref5$actions === undefined ? [] : _ref5$actions;

    return actions.reduce(function (targetOptions, action) {
        targetOptions = toggleOption({
            options: targetOptions,
            option: action.target,
            action: action.action,
            lexicon: lexicon
        });
        return targetOptions;
    }, options);
}

/* eslint-disable no-param-reassign */
function toggleOptionRecursively() {
    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref6$options = _ref6.options,
        options = _ref6$options === undefined ? [] : _ref6$options,
        _ref6$option = _ref6.option,
        option = _ref6$option === undefined ? '' : _ref6$option,
        _ref6$lexicon = _ref6.lexicon,
        lexicon = _ref6$lexicon === undefined ? {} : _ref6$lexicon,
        _ref6$action = _ref6.action,
        action = _ref6$action === undefined ? TYPES.SET_RULE_ACTION : _ref6$action;

    if (!lexicon.options[option]) {
        return options;
    }
    if (TYPES.SET_RULE_ACTION === action) {
        if (options.indexOf(option) > -1) {
            return options;
        }
        options.push(option);
    } else if (TYPES.UNSET_RULE_ACTION === action) {
        if (options.indexOf(option) === -1) {
            return options;
        }
        options = without(options, option);
    }
    var optionRules = Lexicon.getOptionRules({
        option: option,
        type: action === TYPES.SET_RULE_ACTION ? TYPES.SET_OPTION_TRIGGERD_RULES : TYPES.UNSET_OPTION_TRIGGERD_RULES,
        lexicon: lexicon
    });
    // See the definations from https://confluence.teslamotors.com/display/OC/Understanding+the+Options+Warehouse+Data
    if (optionRules) {
        optionRules.forEach(function (optionRule) {
            var action = optionRule.action,
                target = optionRule.target,
                operator = optionRule.operator,
                operatorConditions = optionRule.operatorConditions,
                conditionCode = optionRule.conditionCode,
                conditionState = optionRule.conditionState;

            var applyRuleFlag = true;
            if (conditionCode && conditionState) {
                if (TYPES.UNSET_RULE_ACTION === conditionState && options.indexOf(conditionCode) === -1) {
                    applyRuleFlag = true;
                } else if (TYPES.SET_RULE_ACTION === conditionState && options.indexOf(conditionCode) > -1) {
                    applyRuleFlag = true;
                } else {
                    applyRuleFlag = false;
                }
            }
            if (operator) {
                if (TYPES.RULE_OPERATOR_AND === operator) {
                    applyRuleFlag = true;
                    operatorConditions.forEach(function (_ref7) {
                        var conditionCode = _ref7.conditionCode,
                            conditionState = _ref7.conditionState;

                        if (conditionState === TYPES.UNSET_RULE_ACTION && options.indexOf(conditionCode) > -1) {
                            applyRuleFlag = false;
                        } else if (conditionState === TYPES.SET_RULE_ACTION && options.indexOf(conditionCode) === -1) {
                            applyRuleFlag = false;
                        }
                    });
                } else if (TYPES.RULE_OPERATOR_OR === operator) {
                    applyRuleFlag = false;
                    operatorConditions.forEach(function (_ref8) {
                        var conditionCode = _ref8.conditionCode,
                            conditionState = _ref8.conditionState;

                        if (conditionState === TYPES.UNSET_RULE_ACTION && options.indexOf(conditionCode) === -1) {
                            applyRuleFlag = true;
                        } else if (conditionState === TYPES.SET_RULE_ACTION && options.indexOf(conditionCode) > -1) {
                            applyRuleFlag = true;
                        }
                    });
                }
            }
            if (applyRuleFlag) {
                options = toggleOptionRecursively({
                    options: options,
                    lexicon: lexicon,
                    option: target,
                    action: action
                });
            }
        });
    }
    return options;
}