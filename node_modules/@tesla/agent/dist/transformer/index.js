'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Rx = require('rxjs/Rx');
var difference = require('lodash/difference');

var Configuration = require('../utils/configuration');
var Lexicon = require('../utils/lexicon');
var TYPES = require('../utils/types');
var Utils = require('../utils/index');
var Validator = require('../validator');

module.exports = {
    transform: transform,
    transformPromise: transformPromise,
    transformObservable$: transformObservable$,
    transformWithRules: transformWithRules,
    applyRule: applyRule,
    validateRule: validateRule,
    mapOptions: mapOptions
};

var TRANSFORM_MKT_TO_MFG_TYPES = [TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING, TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_BY_VMID, TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_WITH_CUSTOM_PRICING, TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_BY_VMID_WITH_CUSTOM_PRICING];

function transform() {
    var configurations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var transformCallback = arguments[1];
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING;

    transformObservable$(configurations, type).subscribe(function (result) {
        if (transformCallback) {
            transformCallback(result);
        }
    });
}

function transformPromise() {
    var configurations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING;

    return transformObservable$(configurations, type).toPromise();
}

function transformObservable$() {
    var configurations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING;

    var normalizedConfigurations = Utils.normalizeInput(configurations);
    return Rx.Observable.from(normalizedConfigurations).concatMap(function (configuration) {
        return transformConfigurationObservable$(configuration, type);
    }).toArray().map(function (result) {
        return Utils.normalizeOutput(configurations, result);
    });
}

function transformConfigurationObservable$() {
    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING;

    return Lexicon.getLexicon$(configuration, type).map(function () {
        var lexicons = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        return transformWithRules(configuration, lexicons, type);
    }).map(function (result) {
        return Utils.httpExceptionTransform(result);
    });
}

function transformWithRules(configuration) {
    var lexicons = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING;

    var sourceOptionList = Configuration.getOptionList(configuration);
    if (!Array.isArray(lexicons) || lexicons.indexOf(TYPES.EXCEPTION_HTTP_REQUEST) > -1) {
        return {
            success: false,
            code: TYPES.EXCEPTION_HTTP_REQUEST,
            message: 'Please provide valid transformation lexicons array [marketing, transformation, manufacturing]'
        };
    } else if (TRANSFORM_MKT_TO_MFG_TYPES.indexOf(type) > -1) {
        var marketValidationResult = Validator.validateRulesAndPrice(configuration, type, lexicons[TYPES.TRANSFORM_LEXICON_MARKETING]);
        if (marketValidationResult.success) {
            return transfromFromMktToMfg(sourceOptionList, lexicons);
        }
        return marketValidationResult;
    }
    return transfromFromMfgToMkt(sourceOptionList, lexicons, type);
}

function mapOptions(sourceOptionList) {
    var lexicons = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING;

    if (TRANSFORM_MKT_TO_MFG_TYPES.indexOf(type) > -1) {
        return transfromFromMktToMfg(sourceOptionList, lexicons);
    }
    return transfromFromMfgToMkt(sourceOptionList, lexicons);
}

/* eslint-disable no-param-reassign */
function transfromFromMfgToMkt(sourceOptionList, lexicons) {
    var manufacturingValidationResult = Validator.validateRules(sourceOptionList, lexicons[TYPES.TRANSFORM_LEXICON_MANUFACTURING]);
    if (manufacturingValidationResult.success) {
        var transformingLexicon = Lexicon.normalizeLexiconForManufacturingToMarketing(lexicons[TYPES.TRANSFORM_LEXICON]);
        var marketingLexicon = Lexicon.normalizeLexicon(lexicons[TYPES.TRANSFORM_LEXICON_MARKETING]);
        var optionsInTransformingLexicon = transformingLexicon.options;
        var mappedOptions = Object.keys(optionsInTransformingLexicon).reduce(function (targetOptions, option) {
            var _initRulesOfOption;

            var initRulesOfOption = (_initRulesOfOption = {}, _defineProperty(_initRulesOfOption, TYPES.SET_RULE_ACTION, []), _defineProperty(_initRulesOfOption, TYPES.UNSET_RULE_ACTION, []), _initRulesOfOption);
            var filteredRulesOfOption = optionsInTransformingLexicon[option].set_rules.reduce(function (rules, _ref) {
                var action = _ref.action,
                    target = _ref.target;

                rules[action].push(target);
                return rules;
            }, initRulesOfOption);
            var isRequiredOptionsAllSet = difference(filteredRulesOfOption[TYPES.SET_RULE_ACTION], sourceOptionList).length === 0;
            var isExclusiveOptionsAllUnset = difference(filteredRulesOfOption[TYPES.UNSET_RULE_ACTION], difference(filteredRulesOfOption[TYPES.UNSET_RULE_ACTION], sourceOptionList)).length === 0;
            if (isRequiredOptionsAllSet && isExclusiveOptionsAllUnset) {
                targetOptions = Validator.toggleOption({
                    options: targetOptions,
                    lexicon: marketingLexicon,
                    action: TYPES.SET_RULE_ACTION,
                    option: option
                });
            }
            return targetOptions;
        }, marketingLexicon.base_configuration);

        return {
            data: {
                market: marketingLexicon.market,
                language: marketingLexicon.language,
                product: marketingLexicon.product,
                name: marketingLexicon.name,
                effectiveDate: marketingLexicon.effective_date,
                options: mappedOptions.map(function (option) {
                    return {
                        code: option,
                        price: marketingLexicon.options[option].price
                    };
                })
            },
            success: true,
            code: TYPES.TRANSFORM_RESULT_TYPE_SUCCESS
        };
    }
    return manufacturingValidationResult;
}

function transfromFromMktToMfg(sourceOptionList, lexicons) {
    var marketValidationResult = Validator.validateRules(sourceOptionList, lexicons[TYPES.TRANSFORM_LEXICON_MARKETING]);
    if (marketValidationResult.success) {
        var transformingLexicon = Lexicon.normalizeLexicon(lexicons[TYPES.TRANSFORM_LEXICON]);
        var manufacturingLexicon = Lexicon.normalizeLexicon(lexicons[TYPES.TRANSFORM_LEXICON_MANUFACTURING]);
        var mappedOptionsWithRegion = mapRegionRelatedRules(lexicons[TYPES.TRANSFORM_LEXICON_MARKETING].market, transformingLexicon, manufacturingLexicon);
        var mappedOptions = mapOptionsWithRules(mappedOptionsWithRegion, sourceOptionList, transformingLexicon, manufacturingLexicon);
        return {
            data: mappedOptions,
            success: true,
            code: TYPES.TRANSFORM_RESULT_TYPE_SUCCESS
        };
    }
    return marketValidationResult;
}

function mapRegionRelatedRules() {
    var market = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'US';
    var transformingLexicon = arguments[1];
    var manufacturingLexicon = arguments[2];

    return Validator.toggleOptions({
        options: manufacturingLexicon.base_configuration,
        lexicon: manufacturingLexicon,
        actions: transformingLexicon.region[market].set_rules
    });
}

/* eslint-disable no-param-reassign */
function mapOptionsWithRules() {
    var targetOptionList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var sourceOptionList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var transformingLexicon = arguments[2];
    var manufacturingLexicon = arguments[3];

    return sourceOptionList.reduce(function (targetOptions, sourceOption) {
        var transformingRuleOfOption = transformingLexicon.options[sourceOption];
        if (transformingRuleOfOption && transformingRuleOfOption.set_rules) {
            transformingRuleOfOption.set_rules.forEach(function (transformingRule) {
                targetOptions = applyRule(targetOptions, sourceOptionList, transformingRule, manufacturingLexicon);
            });
        }
        return targetOptions;
    }, targetOptionList);
}

/* eslint-disable no-param-reassign */
function applyRule(targetOptionList, sourceOptionList, transformingRule, manufacturingLexicon) {
    if (validateRule(targetOptionList, sourceOptionList, transformingRule)) {
        targetOptionList = Validator.toggleOption({
            options: targetOptionList,
            lexicon: manufacturingLexicon,
            option: transformingRule.target,
            action: transformingRule.action
        });
    }
    return targetOptionList;
}

function validateRule(targetOptionList, sourceOptionList, transformingRule) {
    var operator = transformingRule.operator,
        operatorConditions = transformingRule.operatorConditions,
        conditionCode = transformingRule.conditionCode,
        conditionState = transformingRule.conditionState;

    var isRuleValid = true;
    if (conditionCode && conditionState) {
        // For set rule, if the conditionCode is missing from target/source option list, we won't apply the rule
        if (TYPES.SET_RULE_ACTION === conditionState && targetOptionList.indexOf(conditionCode) === -1 && sourceOptionList.indexOf(conditionCode) === -1) {
            isRuleValid = false;
            // For unset rule, if the conditionCode exists in target/source option list, we won't apply the rule
        } else if (conditionState === TYPES.UNSET_RULE_ACTION && (targetOptionList.indexOf(conditionCode) > -1 || sourceOptionList.indexOf(conditionCode) > -1)) {
            isRuleValid = false;
        }
    }
    if (operator) {
        if (TYPES.RULE_OPERATOR_AND === operator) {
            isRuleValid = true;
            operatorConditions.forEach(function (_ref2) {
                var conditionCode = _ref2.conditionCode,
                    conditionState = _ref2.conditionState;

                // For unset rule, if any of the conditionCode exists in target/source option list, we won't apply the rule
                if (conditionState === TYPES.UNSET_RULE_ACTION && (targetOptionList.indexOf(conditionCode) > -1 || sourceOptionList.indexOf(conditionCode) > -1)) {
                    isRuleValid = false;
                    // For set rule, if any of the conditionCode is missing from target/source option list, we won't apply the rule
                } else if (conditionState === TYPES.SET_RULE_ACTION && targetOptionList.indexOf(conditionCode) === -1 && sourceOptionList.indexOf(conditionCode) === -1) {
                    isRuleValid = false;
                }
            });
        } else if (TYPES.RULE_OPERATOR_OR === operator) {
            isRuleValid = false;
            operatorConditions.forEach(function (_ref3) {
                var conditionCode = _ref3.conditionCode,
                    conditionState = _ref3.conditionState;

                // For unset rule, if any of the conditionCode is missing in target/source option list, we will apply the rule
                if (conditionState === TYPES.UNSET_RULE_ACTION && (targetOptionList.indexOf(conditionCode) === -1 || sourceOptionList.indexOf(conditionCode) === -1)) {
                    isRuleValid = true;
                    // For set rule, if any of the conditionCode exists in target/source option list, we will apply the rule
                } else if (conditionState === TYPES.SET_RULE_ACTION && (targetOptionList.indexOf(conditionCode) > -1 || sourceOptionList.indexOf(conditionCode) > -1)) {
                    isRuleValid = true;
                }
            });
        }
    }
    return isRuleValid;
}