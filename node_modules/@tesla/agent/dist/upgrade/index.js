'use strict';

var intersection = require('lodash/intersection');
var TYPES = require('../utils/types');
var Validator = require('../validator');
var Lexicon = require('../utils/lexicon');

module.exports = {
    upgrade: upgrade,
    getEligibleUpgradableOptions: getEligibleUpgradableOptions
};

/* eslint-disable no-param-reassign */
function upgrade() {
    var optionList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var lexicon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var normalizedLexicon = Lexicon.normalizeLexicon(lexicon);
    var validationResult = Validator.validateRules(optionList, normalizedLexicon);
    if (validationResult.success) {
        var upgradableOptionList = combination(getEligibleUpgradableOptions(optionList, normalizedLexicon));
        var potentialUpgradedConfigurationList = upgradableOptionList.reduce(function (upgradedConfigurationList, upgradableOptions) {
            var upgradedConfiguration = upgradableOptions.reduce(function (options, upgradableOption) {
                options = Validator.toggleOption({
                    options: options,
                    option: upgradableOption,
                    lexicon: normalizedLexicon
                });
                return options;
            }, optionList);
            upgradedConfigurationList.push({
                'upgradedOptions': upgradedConfiguration,
                'sourceOptions': optionList,
                upgradableOptions: upgradableOptions
            });
            return upgradedConfigurationList;
        }, []);
        return {
            success: true,
            data: potentialUpgradedConfigurationList
        };
    }
    validationResult.code = TYPES.UPGRADE_RESULT_TYPE_INVALID_CONFIGURATION;
    return validationResult;
}

function getEligibleUpgradableOptions() {
    var optionList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var lexicon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var upgradableOptions = [];
    if (lexicon.metadata && lexicon.metadata.post_mfg_mutations) {
        var upgrades = lexicon.metadata.post_mfg_mutations;
        upgradableOptions = Object.keys(upgrades).filter(function (upgradableOption) {
            var _upgrades$upgradableO = upgrades[upgradableOption],
                type = _upgrades$upgradableO.type,
                mutation = _upgrades$upgradableO.mutation,
                requirement_relationship = _upgrades$upgradableO.requirement_relationship;

            if (TYPES.UPGRADE_TYPE_NOT_AVAILABLE !== type && optionList.indexOf(upgradableOption) === -1) {
                if (Array.isArray(mutation) && mutation.length) {
                    if (TYPES.RULE_OPERATOR_AND === requirement_relationship) {
                        return intersection(mutation, optionList).length === mutation.length;
                    } else if (TYPES.RULE_OPERATOR_OR === requirement_relationship) {
                        return intersection(mutation, optionList).length;
                    }
                } else {
                    return true;
                }
            }
            return false;
        });
    }
    return upgradableOptions;
}

function combination(set) {
    var binary = [];
    var output = [];
    var totalSubSets = Math.pow(2, set.length);
    /* eslint-disable no-plusplus */
    for (var i = 0; i < totalSubSets; i++) {
        binary.push(i.toString(2));
    }
    binary.forEach(function (element) {
        element = element.split('').reverse();
        var sub = [];
        element.forEach(function (item, index) {
            if (item === '1') {
                sub.push(set[index]);
            }
        });
        if (sub.length) {
            output.push(sub);
        }
    });
    return output;
}