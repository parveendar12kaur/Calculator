'use strict';

var uuidv4 = require('uuid/v4');
var Utils = require('./index');
var TYPES = require('./types');
var ENV = require('../env');
var each = require('lodash/each');
var groupBy = require('lodash/groupBy');

module.exports = {
    getGroupOfOptions: getGroupOfOptions,
    getExclusiveGroups: getExclusiveGroups,
    getRequiredGroups: getRequiredGroups,
    getOptionRules: getOptionRules,
    getGroupsByProperty: getGroupsByProperty,
    normalizeRule: normalizeRule,
    getLexicon$: getLexicon$,
    normalizeLexicon: normalizeLexicon,
    normalizeLexiconForManufacturingToMarketing: normalizeLexiconForManufacturingToMarketing
};

function getGroupOfOptions() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var lexicon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var optionsInLexicon = lexicon.options;
    return options.reduce(function (groups, option) {
        if (optionsInLexicon[option]) {
            groups.push(optionsInLexicon[option].group);
        }
        return groups;
    }, []);
}

function getExclusiveGroups(lexicon) {
    return getGroupsByProperty(lexicon, 'exclusive');
}

function getRequiredGroups(lexicon) {
    return getGroupsByProperty(lexicon, 'required');
}

function getOptionRules(_ref) {
    var lexicon = _ref.lexicon,
        option = _ref.option,
        type = _ref.type;

    var rules = [];
    var optionInLexicon = lexicon.options[option];
    if (optionInLexicon && optionInLexicon[type]) {
        rules = optionInLexicon[type] || rules;
    }
    return rules;
}

function getGroupsByProperty(lexicon, property) {
    return lexicon.groups.filter(function (item) {
        return !item.groups || isNotUIOnlyGroups(item);
    }).filter(function (item) {
        return item[property];
    }).map(function (item) {
        return item.code;
    });
}

function normalizeRule() {
    var rules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    var normalizedRules = [];
    var tempRule = {};
    var composedRuleStarted = false;
    rules.forEach(function (rule) {
        if (rule.operator) {
            if (!composedRuleStarted) {
                tempRule = {
                    operatorConditions: [],
                    action: rule.action,
                    target: rule.target,
                    operator: rule.operator
                };
                composedRuleStarted = true;
            }
            if (rule.operator && composedRuleStarted) {
                tempRule.operatorConditions.push({
                    conditionCode: rule.condition_code,
                    conditionState: rule.condition_state
                });
            }
        } else if (composedRuleStarted) {
            tempRule.operatorConditions.push({
                conditionCode: rule.condition_code,
                conditionState: rule.condition_state
            });
            composedRuleStarted = false;
            normalizedRules.push(tempRule);
        } else if (rule.condition_code) {
            normalizedRules.push({
                action: rule.action,
                target: rule.target,
                conditionCode: rule.condition_code,
                conditionState: rule.condition_state
            });
        } else {
            normalizedRules.push(rule);
        }
    });
    return normalizedRules;
}

function getLexicon$(_ref2, type) {
    var market = _ref2.market,
        language = _ref2.language,
        model = _ref2.model,
        id = _ref2.id;
    var date = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var requestId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : uuidv4();

    var endpoint = '';
    switch (type) {
        // Validation section
        case TYPES.VALIDATION_TYPE_MARKETING:
        case TYPES.VALIDATION_TYPE_MARKETING_WITH_CUSTOM_PRICING:
            endpoint = ENV.OCW_API_HOST + '/lexicon/' + TYPES.OCW_MARKETING_LEXICON + '/' + market + '/' + language + '/' + model + '?date=' + date;
            break;
        case TYPES.VALIDATION_TYPE_MARKETING_BY_VMID:
        case TYPES.VALIDATION_TYPE_MARKETING_BY_VMID_WITH_CUSTOM_PRICING:
        case TYPES.UPGRADE_LEXICON_MARKETING:
            endpoint = ENV.OCW_LBN_HOST + '/lexicon/' + TYPES.OCW_MARKETING_LEXICON + '/' + id;
            break;
        case TYPES.VALIDATION_TYPE_MANUFACTURING:
            // Here we only have one manufacturing lexicon, so take US/en
            endpoint = ENV.OCW_API_HOST + '/lexicon/' + TYPES.OCW_MANUFACTURING_LEXICON + '/US/en/' + model + '?date=' + date;
            break;
        case TYPES.VALIDATION_TYPE_MANUFACTURING_BY_VID:
            endpoint = ENV.OCW_LBN_HOST + '/lexicon/' + TYPES.OCW_MANUFACTURING_LEXICON + '/' + id;
            break;
        // Transformation section
        case TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING:
        case TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_WITH_CUSTOM_PRICING:
        case TYPES.TRANSFORM_MANUFACTURING_TO_MARKETING:
            endpoint = ENV.OCW_API_HOST + '/lexicon/' + TYPES.OCW_TRANSFORMATION_LEXICON + '/' + market + '/' + language + '/' + model + '?date=' + date;
            break;
        case TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_BY_VMID:
        case TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_BY_VMID_WITH_CUSTOM_PRICING:
            endpoint = ENV.OCW_LBN_HOST + '/lexicon/' + TYPES.OCW_TRANSFORMATION_MARKETING_TO_MANUFACTURING_LEXICON + '/' + id;
            break;
        case TYPES.TRANSFORM_MANUFACTURING_TO_MARKETING_BY_VID:
            endpoint = ENV.OCW_LBN_HOST + '/lexicon/' + TYPES.OCW_TRANSFORMATION_MANUFACTURING_TO_MARKETING_LEXICON + '/' + id;
            break;
        // Migration section
        case TYPES.MIGRATION_LEXICON_MARKETING:
            endpoint = ENV.OCW_API_HOST + '/lexicon/' + TYPES.OCW_MARKETING_LEXICON + '/' + market + '/' + language + '/' + model + '?date=' + date;
            break;
        case TYPES.MIGRATION_LEXICON_MANUFACTURING:
            // Here we only have one manufacturing lexicon, so take US/en
            endpoint = ENV.OCW_API_HOST + '/lexicon/' + TYPES.OCW_MANUFACTURING_LEXICON + '/US/en/' + model + '?date=' + date;
            break;
        // Matching section
        case TYPES.MATCHING_INVENTORY:
            endpoint = ENV.OCW_LBN_HOST + '/lexicon/' + TYPES.OCW_MANUFACTURING_LEXICON + '/' + id + '?context[]=' + TYPES.OCW_DEFAULT_CONTEXT + '&context[]=' + TYPES.OCW_MATCHING_CONTEXT;
            break;
    }
    if (!endpoint) {
        console.log('WARNING: Make sure you have provided correct environment informations for Agent');
    }
    console.log(requestId + ' Getting lexicon from ' + endpoint + ' with APIKEY ' + ENV.OCW_API_TOKEN);

    return Utils.httpGetObservable$(endpoint, {
        headers: {
            'x-api-key': ENV.OCW_API_TOKEN,
            'Cache-Control': 'no-store',
            'X-Request-Id': requestId
        }
    }).map(function (lexicon) {
        if (Array.isArray(lexicon)) {
            return lexicon.map(function (lexiconItem) {
                return normalizeLexicon(lexiconItem);
            });
        }
        return normalizeLexicon(lexicon);
    });
}

/* eslint-disable no-param-reassign */
function normalizeLexicon(sourceLexicon) {
    sourceLexicon = validateLexicon(sourceLexicon);
    if (sourceLexicon === TYPES.EXCEPTION_HTTP_REQUEST || sourceLexicon.normalized) {
        return sourceLexicon;
    }
    var lexicon = Utils.deepClone(sourceLexicon);
    if (lexicon.groups) {
        lexicon.matching = lexicon.groups.filter(function (group) {
            return group.context === TYPES.OCW_MATCHING_CONTEXT;
        });
        lexicon.groups = lexicon.groups.filter(function (group) {
            return group.context === TYPES.OCW_DEFAULT_CONTEXT && isNotUIOnlyGroups(group) && group.options && group.options.length;
        });
    }
    var groupsInLexicon = lexicon.groups;
    var optionsInLexicon = lexicon.options;
    if (groupsInLexicon) {
        groupsInLexicon.forEach(function (_ref3) {
            var code = _ref3.code,
                options = _ref3.options;

            if (options) {
                options.forEach(function (option) {
                    if (lexicon.options[option]) {
                        lexicon.options[option].group = code;
                    }
                });
            }
        });
    }
    if (optionsInLexicon) {
        each(optionsInLexicon, function (_ref4, optionCode) {
            var set_rules = _ref4.set_rules,
                unset_rules = _ref4.unset_rules;

            lexicon.options[optionCode].set_rules = normalizeRule(set_rules);
            lexicon.options[optionCode].unset_rules = normalizeRule(unset_rules);
        });
    }
    if (!lexicon.metadata) {
        lexicon.metadata = {};
    }
    lexicon.normalized = true;
    return lexicon;
}

// Filter out the conditional / operator rules in transformation lexicon, only keep the rules which target option code must be set when we do mkt => mfg exploding.
function normalizeLexiconForManufacturingToMarketing(sourceLexicon) {
    if (sourceLexicon === TYPES.EXCEPTION_HTTP_REQUEST || sourceLexicon.normalizedForManufacturingToMarketing) {
        return sourceLexicon;
    }
    var lexicon = normalizeLexicon(sourceLexicon);
    var optionsInLexicon = lexicon.options;
    if (optionsInLexicon) {
        each(optionsInLexicon, function (_ref5, optionCode) {
            var _ref5$set_rules = _ref5.set_rules,
                set_rules = _ref5$set_rules === undefined ? [] : _ref5$set_rules;

            // Only keep the rule which target action can't be unset when we do mkt => mft exploding, then we can use them to do the reverse mapping
            var rulesByTarget = groupBy(set_rules, 'target');
            var validTargetOfRules = [];
            Object.keys(rulesByTarget).forEach(function (target) {
                var rulesByAction = groupBy(rulesByTarget[target], 'action');
                if (rulesByAction[TYPES.SET_RULE_ACTION] && !rulesByAction[TYPES.UNSET_RULE_ACTION]) {
                    validTargetOfRules.push(target);
                } else if (!rulesByAction[TYPES.SET_RULE_ACTION] && rulesByAction[TYPES.UNSET_RULE_ACTION]) {
                    validTargetOfRules.push(target);
                }
            });
            lexicon.options[optionCode].set_rules = set_rules.reduce(function (validRules, rule) {
                if (validTargetOfRules.indexOf(rule.target) > -1 && !rule.operator && (!rule.conditionCode && !rule.conditionAction || rule.conditionCode === optionCode && rule.conditionState === TYPES.SET_RULE_ACTION)) {
                    validRules.push(rule);
                }
                return validRules;
            }, []);
        });
    }
    lexicon.normalizedForManufacturingToMarketing = true;
    return lexicon;
}

function validateLexicon(lexicon) {
    if (lexicon && lexicon.options) {
        return lexicon;
    }
    return TYPES.EXCEPTION_HTTP_REQUEST;
}

function isNotUIOnlyGroups(group) {
    return !group.groups || group.groups && Array.isArray(group.groups) && group.groups.length === 0;
}