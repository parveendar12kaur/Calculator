const without = require('lodash/without');
const TYPES = require('../utils/types');
const Configuration = require('../utils/configuration');
const Lexicon = require('../utils/lexicon');
const Validator = require('../validator');

module.exports = {
    migrate,
    transformMigrationLexiconForDowngrade
};

/* eslint-disable no-param-reassign */
function migrate(configuration = {}, sourceLexicon = {}, targetLexicon = {}) {
    const sourceOptionList = Configuration.getOptionList(configuration);
    const normalizedSourceLexicon = Lexicon.normalizeLexicon(sourceLexicon);
    const normalizedTargetLexicon = Lexicon.normalizeLexicon(targetLexicon);
    const validationResult = Validator.validateRules(sourceOptionList, normalizedSourceLexicon);
    if (validationResult.success) {
        let migrationType = getMigrationType(normalizedSourceLexicon, normalizedTargetLexicon);
        if (TYPES.MIGRATION_LEXICON_CROSS_COUNTRY === migrationType) {
            return {
                success: false,
                message: 'We can\'t handle cross country migration now.',
                code: TYPES.MIGRATION_RESULT_TYPE_UNSUPPORTED_MIGRATION
            };
        }
        let migratedOptionList = [];
        let migrationsInSourceLexicon = normalizedSourceLexicon.metadata.migrations || [];
        let migrationsInTargetLexicon = normalizedTargetLexicon.metadata.migrations || [];
        switch (migrationType) {
        case TYPES.MIGRATION_LEXICON_DIRECTION_UPGRADE:
            migratedOptionList = upgrade(sourceOptionList, migrationsInTargetLexicon.slice(migrationsInSourceLexicon.length), normalizedTargetLexicon);
            break;
        case TYPES.MIGRATION_LEXICON_DIRECTION_DOWNGRADE:
            migratedOptionList = downgrade(sourceOptionList, migrationsInSourceLexicon.slice(migrationsInTargetLexicon.length), normalizedTargetLexicon);
            break;
        }
        let configurationAfterMigration = migratedOptionList.reduce((options, option) => {
            options = Validator.toggleOption({
                lexicon: normalizedTargetLexicon,
                actions: TYPES.SET_RULE_ACTION,
                options,
                option
            });
            return options;
        }, normalizedTargetLexicon.base_configuration);
        return {
            success: true,
            data: configurationAfterMigration
        };
    }
    validationResult.code = TYPES.MIGRATION_RESULT_TYPE_INVALID_CONFIGURATION;
    return validationResult;
}

function upgrade(sourceOptionList, migrationLexicon, targetLexicon) {
    let optionList = sourceOptionList.slice(0);
    migrationLexicon.forEach(migrationItem => {
        let normalizedMigrationItem = Lexicon.normalizeLexicon(migrationItem);
        Object.keys(normalizedMigrationItem.options).forEach(migrationOptionCode => {
            if (optionList.indexOf(migrationOptionCode) > -1) {
                let action = targetLexicon.options[migrationOptionCode] ? TYPES.SET_RULE_ACTION : TYPES.UNSET_RULE_ACTION;
                let rulesType = action === TYPES.SET_RULE_ACTION ? TYPES.SET_OPTION_TRIGGERD_RULES : TYPES.UNSET_OPTION_TRIGGERD_RULES;
                optionList = migrationOption(optionList, normalizedMigrationItem.options[migrationOptionCode][rulesType]);
            }
        });
    });
    return optionList;
}

function downgrade(sourceOptionList, migrationLexicon, targetLexicon) {
    let optionList = sourceOptionList.slice(0);
    let downgradeMigrations = transformMigrationLexiconForDowngrade(migrationLexicon);
    downgradeMigrations.forEach(migrationItem => {
        let normalizedMigrationItem = Lexicon.normalizeLexicon(migrationItem);
        Object.keys(normalizedMigrationItem.options).forEach(migrationOptionCode => {
            if (optionList.indexOf(migrationOptionCode) > -1) {
                let action = targetLexicon.options[migrationOptionCode] ? TYPES.SET_RULE_ACTION : TYPES.UNSET_RULE_ACTION;
                let rulesType = action === TYPES.SET_RULE_ACTION ? TYPES.SET_OPTION_TRIGGERD_RULES : TYPES.UNSET_OPTION_TRIGGERD_RULES;
                optionList = migrationOption(optionList, normalizedMigrationItem.options[migrationOptionCode][rulesType]);
            }
        });
    });
    return optionList;
}

function transformMigrationLexiconForDowngrade(migrationLexicon) {
    return migrationLexicon.reverse().map(migrationItem => {
        let normalizedMigrationItem = Lexicon.normalizeLexicon(migrationItem);
        let transformedRules = Object.keys(normalizedMigrationItem.options).reduce((rules, migrationOptionCode) => {
            let setOptionRules = normalizedMigrationItem.options[migrationOptionCode][TYPES.SET_OPTION_TRIGGERD_RULES];
            let unsetOptionRules = normalizedMigrationItem.options[migrationOptionCode][TYPES.UNSET_OPTION_TRIGGERD_RULES];
            if (unsetOptionRules.length > 0) {
                // Build the rules dynamically with the new option code we set in new lexicon
                let setRulesInUnsetOptionRules = unsetOptionRules.filter(rule => rule.action === TYPES.SET_RULE_ACTION);
                let reversedUnsetRules = unsetOptionRules.reduce((reversedRules, rule) => {
                    if (rule.action === TYPES.UNSET_RULE_ACTION) {
                        reversedRules.push(reverseRuleAction(rule));
                    }
                    return reversedRules;
                }, []);
                setRulesInUnsetOptionRules.forEach(rule => {
                    let reversedSetRule = [reverseRuleAction(rule)];
                    rules[rule.target] = {
                        [TYPES.UNSET_OPTION_TRIGGERD_RULES]: reversedSetRule.concat(reversedUnsetRules)
                    };
                });
            } else {
                setOptionRules = setOptionRules.map(rule => reverseRuleAction(rule));
                rules[migrationOptionCode] = {
                    [TYPES.SET_OPTION_TRIGGERD_RULES]: setOptionRules
                };
            }
            return rules;
        }, {});
        return {
            options: transformedRules
        };
    });
}

function reverseRuleAction(rule) {
    return Object.assign({}, rule, {action: rule.action === TYPES.SET_RULE_ACTION ? TYPES.UNSET_RULE_ACTION : TYPES.SET_RULE_ACTION});
}

function getMigrationType(sourceLexicon, targetLexicon) {
    if (sourceLexicon.market === targetLexicon.market) {
        return getMigrationDirection(sourceLexicon, targetLexicon);
    }
    return TYPES.MIGRATION_LEXICON_CROSS_COUNTRY;
}

function getMigrationDirection(sourceLexicon, targetLexicon) {
    let sourceLexiconEffectiveTimeStamp = +(new Date(sourceLexicon.effective_date));
    let targetLexiconEffectiveTimeStamp = +(new Date(targetLexicon.effective_date));
    return sourceLexiconEffectiveTimeStamp <= targetLexiconEffectiveTimeStamp ? TYPES.MIGRATION_LEXICON_DIRECTION_UPGRADE : TYPES.MIGRATION_LEXICON_DIRECTION_DOWNGRADE;
}

function migrationOption(optionList = [], optionRules = []) {
    let options = optionList.slice(0);
    // See the definations from https://confluence.teslamotors.com/display/OC/Understanding+the+Options+Warehouse+Data
    if (optionRules && optionRules.length) {
        optionRules.forEach(optionRule => {
            let {action, target, operator, operatorConditions, conditionCode, conditionState} = optionRule;
            let applyRuleFlag = true;
            if (conditionCode && conditionState) {
                if (TYPES.UNSET_RULE_ACTION === conditionState && options.indexOf(conditionCode) === -1) {
                    applyRuleFlag = true;
                } else if (TYPES.SET_RULE_ACTION === conditionState && options.indexOf(conditionCode) > -1) {
                    applyRuleFlag = true;
                } else {
                    applyRuleFlag = false;
                }
            }
            if (operator) {
                if (TYPES.RULE_OPERATOR_AND === operator) {
                    applyRuleFlag = true;
                    operatorConditions.forEach(({conditionCode, conditionState}) => {
                        if (conditionState === TYPES.UNSET_RULE_ACTION && options.indexOf(conditionCode) > -1) {
                            applyRuleFlag = false;
                        } else if (conditionState === TYPES.SET_RULE_ACTION && options.indexOf(conditionCode) === -1) {
                            applyRuleFlag = false;
                        }
                    });
                } else if (TYPES.RULE_OPERATOR_OR === operator) {
                    applyRuleFlag = false;
                    operatorConditions.forEach(({conditionCode, conditionState}) => {
                        if (conditionState === TYPES.UNSET_RULE_ACTION && options.indexOf(conditionCode) === -1) {
                            applyRuleFlag = true;
                        } else if (conditionState === TYPES.SET_RULE_ACTION && options.indexOf(conditionCode) > -1) {
                            applyRuleFlag = true;
                        }
                    });
                }
            }
            if (applyRuleFlag) {
                if (action === TYPES.SET_RULE_ACTION && options.indexOf(target) === -1) {
                    options.push(target);
                }
                if (action === TYPES.UNSET_RULE_ACTION && options.indexOf(target) > -1) {
                    options = without(options, target);
                }
            }
        });
    }
    return options;
}
