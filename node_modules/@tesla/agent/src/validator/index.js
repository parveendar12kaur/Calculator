const difference = require('lodash/difference');
const without = require('lodash/without');
const uniq = require('lodash/uniq');
const Rx = require('rxjs/Rx');

const Configuration = require('../utils/configuration');
const TYPES = require('../utils/types');
const Lexicon = require('../utils/lexicon');
const Utils = require('../utils/index');

module.exports = {
    validate,
    validatePromise,
    validateObservable$,
    validateRules,
    validateRulesAndPrice,
    validateRulesAndPriceWithSubtotal,
    validatePrice,
    validatePriceWithSubtotal,
    validateDuplication,
    validateRequired,
    validateOptionSetRules,
    validateArbitraryOptions,
    toggleOption,
    toggleOptions,
    toggleOptionByGroup,
    getOptionPrice
};

const LEXICON_WITH_PRICES = [
    TYPES.VALIDATION_TYPE_MARKETING,
    TYPES.VALIDATION_TYPE_MARKETING_BY_VMID,
    TYPES.VALIDATION_TYPE_MARKETING_WITH_CUSTOM_PRICING,
    TYPES.VALIDATION_TYPE_MARKETING_BY_VMID_WITH_CUSTOM_PRICING,
    TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING,
    TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_BY_VMID,
    TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_WITH_CUSTOM_PRICING,
    TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_BY_VMID_WITH_CUSTOM_PRICING
];

const CUSTOMIZE_PRICING_VALIDATION_TYPES = [
    TYPES.VALIDATION_TYPE_MARKETING_WITH_CUSTOM_PRICING,
    TYPES.VALIDATION_TYPE_MARKETING_BY_VMID_WITH_CUSTOM_PRICING,
    TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_WITH_CUSTOM_PRICING,
    TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_BY_VMID_WITH_CUSTOM_PRICING
];

function validate(configurations = [], validationCallback, type = TYPES.VALIDATION_TYPE_MARKETING) {
    validateObservable$(configurations, type).subscribe(
        result => {
            if (validationCallback) {
                validationCallback(result);
            }
        }
    );
}

function validatePromise(configurations = [], type = TYPES.VALIDATION_TYPE_MARKETING) {
    return validateObservable$(configurations, type).toPromise();
}

function validateObservable$(configurations = [], type = TYPES.VALIDATION_TYPE_MARKETING) {
    let normalizedConfigurations = Utils.normalizeInput(configurations);
    return Rx.Observable.from(normalizedConfigurations)
               .concatMap(configuration => validateConfigurationObservable$(configuration, type))
               .toArray()
               .map(result => Utils.normalizeOutput(configurations, result));
}

function validateConfigurationObservable$(configuration = {}, type = TYPES.VALIDATION_TYPE_MARKETING) {
    return Lexicon.getLexicon$(configuration, type)
        .map(lexicon => validateRulesAndPrice(configuration, type, lexicon))
        .map(result => Utils.httpExceptionTransform(result));
}

function validateRulesAndPrice(configuration, type, lexicon) {
    let sourceOptionList = Configuration.getOptionList(configuration);
    let groupAndRulesValidationResult = validateRules(sourceOptionList, lexicon);
    if (!groupAndRulesValidationResult.success || LEXICON_WITH_PRICES.indexOf(type) === -1) {
        return groupAndRulesValidationResult;
    }
    return validatePrice(configuration.options, lexicon, type);
}

function validateRulesAndPriceWithSubtotal(configuration, type, lexicon) {
    let sourceOptionList = Configuration.getOptionList(configuration);
    let groupAndRulesValidationResult = validateRules(sourceOptionList, lexicon);
    if (!groupAndRulesValidationResult.success || LEXICON_WITH_PRICES.indexOf(type) === -1) {
        return groupAndRulesValidationResult;
    }
    let optionPriceValidationResult = validatePrice(configuration.options, lexicon, type);
    if (!optionPriceValidationResult.success) {
        return optionPriceValidationResult;
    }
    return validateSubtotal(configuration);
}

function validateRules(sourceOptionList, lexicon) {
    if (lexicon === TYPES.EXCEPTION_HTTP_REQUEST) {
        return Rx.Observable.of(lexicon);
    }
    const transformedLexicon = Lexicon.normalizeLexicon(lexicon);

    let arbitraryValidationResult = validateArbitraryOptions(sourceOptionList, transformedLexicon);
    if (!arbitraryValidationResult.success) {
        return arbitraryValidationResult;
    }
    let groupOfOptions = Lexicon.getGroupOfOptions(sourceOptionList, transformedLexicon)
        .slice()
        .sort();
    let duplicationValidationResult = validateDuplication(groupOfOptions, transformedLexicon);
    if (!duplicationValidationResult.success) {
        return duplicationValidationResult;
    }

    let requiredValidationResult = validateRequired(groupOfOptions, transformedLexicon);
    if (!requiredValidationResult.success) {
        return requiredValidationResult;
    }

    return validateOptionSetRules(sourceOptionList, transformedLexicon);
}

function validateDuplication(groupOfOptions, lexicon) {
    const exclusiveGroupInLexicon = Lexicon.getExclusiveGroups(lexicon);
    let exclusiveGroupOfOptions = groupOfOptions.filter(group => exclusiveGroupInLexicon.indexOf(group) > -1);
    let duplicatedGroups = exclusiveGroupOfOptions.filter((item, index) => exclusiveGroupOfOptions[index] === exclusiveGroupOfOptions[index + 1] || exclusiveGroupOfOptions[index] === exclusiveGroupOfOptions[index - 1]);
    let validationResult = exclusiveGroupOfOptions.length === uniq(exclusiveGroupOfOptions).length;
    return {
        success: validationResult,
        message: validationResult ? 'success' : `Duplicated options of group [${uniq(duplicatedGroups).join(', ')}]`,
        code: validationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : TYPES.VALIDATION_RESULT_TYPE_CONTAINS_DUPLICATED_OPTIONS
    };
}

function validateRequired(groupOfOptions, lexicon) {
    const requiredGroupInLexicon = Lexicon.getRequiredGroups(lexicon);
    let missingRequiredGroups = difference(requiredGroupInLexicon, groupOfOptions);
    let validationResult = missingRequiredGroups.length === 0;
    return {
        success: validationResult,
        message: validationResult ? 'success' : `Missing required group [${missingRequiredGroups.join(', ')}]`,
        code: validationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : TYPES.VALIDATION_RESULT_TYPE_MISSING_REQUIRED_OPTIONS
    };
}

function validateArbitraryOptions(sourceOptions, lexicon) {
    const optionsInLexicon = Object.keys(lexicon.options);
    let arbitraryOptions = difference(sourceOptions, optionsInLexicon);
    let validationResult = !arbitraryOptions.length;
    return {
        success: validationResult,
        message: validationResult ? 'success' : `Some option codes doesn't exist in lexicon [${arbitraryOptions.join(', ')}]`,
        code: validationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : TYPES.VALIDATION_RESULT_TYPE_CONTAINS_ARBITRARY_OPTIONS
    };
}

function getOptionPrice(optionCode, lexicon, context = TYPES.OCW_PRICE_DEFAULT_CONTEXT, type = TYPES.OCW_PRICE_TYPE_BASE) {
    let option = lexicon.options[optionCode];
    let price = 0;
    if (option) {
        if (option.pricing) {
            let basePriceItem = option.pricing.filter(pricing => pricing.context === context && pricing.type === type);
            if (basePriceItem && basePriceItem[0]) {
                price = basePriceItem[0].value;
            }
        } else {
            price = option.price;
        }
    }
    return price;
}

function validatePrice(options = [], lexicon = {}, type = TYPES.VALIDATION_TYPE_MARKETING) {
    let mismatchPriceOptions = [];
    options.forEach(({code, price, isCustomPricing}) => {
        let priceFromLexicon = getOptionPrice(code, lexicon);
        let validateCustomizePricing = CUSTOMIZE_PRICING_VALIDATION_TYPES.indexOf(type) > -1;
        if (price !== priceFromLexicon && !(validateCustomizePricing && isCustomPricing)) {
            mismatchPriceOptions.push({
                code,
                price,
                priceFromLexicon
            });
        }
    });
    let validationResult = !mismatchPriceOptions.length;
    return {
        success: validationResult,
        message: validationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : `Price in options are different from lexicon ${JSON.stringify(mismatchPriceOptions)}`,
        code: validationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : TYPES.VALIDATION_RESULT_TYPE_PRICE_TAMPERING
    };
}

function validatePriceWithSubtotal(configuration, lexicon = {}, type = TYPES.VALIDATION_TYPE_MARKETING) {
    let mismatchPriceOptions = [];
    configuration.options.forEach(({code, price, isCustomPricing}) => {
        let priceFromLexicon = getOptionPrice(code, lexicon);
        let validateCustomizePricing = CUSTOMIZE_PRICING_VALIDATION_TYPES.indexOf(type) > -1;
        if (price !== priceFromLexicon && !(validateCustomizePricing && isCustomPricing)) {
            mismatchPriceOptions.push({
                code,
                price,
                priceFromLexicon
            });
        }
    });
    let optionPriceValidationResult = !mismatchPriceOptions.length;
    if (!optionPriceValidationResult) {
        return {
            success: optionPriceValidationResult,
            message: optionPriceValidationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : `Price in options are different from lexicon ${JSON.stringify(mismatchPriceOptions)}`,
            code: optionPriceValidationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : TYPES.VALIDATION_RESULT_TYPE_PRICE_TAMPERING
        };
    }
    return validateSubtotal(configuration);

}

function validateSubtotal(configuration) {
    let calculatedSubtotal = configuration.options.reduce((total, option) => total + parseFloat(option.price, 10), 0);
    let validationResult = parseFloat(configuration.subtotal, 10) === calculatedSubtotal;
    return {
        success: validationResult,
        message: validationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : `Subtotal should be ${calculatedSubtotal}`,
        code: validationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : TYPES.VALIDATION_RESULT_TYPE_PRICE_TAMPERING
    };
}

function validateOptionSetRules(sourceOptions, lexicon) {
    let optionListFromLexiconRules = [];
    sourceOptions.forEach(optionToSet => {
        optionListFromLexiconRules = toggleOption({
            options: optionListFromLexiconRules,
            option: optionToSet,
            action: TYPES.SET_RULE_ACTION,
            lexicon
        });
    });
    let optionsDifference = [difference(sourceOptions, optionListFromLexiconRules), difference(optionListFromLexiconRules, sourceOptions)];
    let validationResult = !(optionsDifference[0].length || optionsDifference[1].length);
    return {
        success: validationResult,
        message: validationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : `Conflicts occurred in options ${optionsDifference[0].join(', ')} or ${optionsDifference[1].join(', ')}`,
        code: validationResult ? TYPES.VALIDATION_RESULT_TYPE_VALID : TYPES.VALIDATION_RESULT_TYPE_CONFLICT_WITH_LEXICON_RULES
    };
}

function toggleOption({options = [], option = '', lexicon = {}, action = TYPES.SET_RULE_ACTION} = {}) {
    let sourceOptions = options.slice(0);
    let transformedLexicon = Lexicon.normalizeLexicon(lexicon);
    return toggleOptionRecursively({
        options: sourceOptions,
        lexicon: transformedLexicon,
        action,
        option
    });
}

/*
 * This method will help the consumer to make the decision, we will set or unset the option
 * Assume the default action is set, only if the option already exists in options and the group of the option is neither exclusive nor required, we will switch the action to unset automatically.
 */

function toggleOptionByGroup({options = [], option = '', lexicon = {}}) {
    let sourceOptions = options.slice(0);
    let transformedLexicon = Lexicon.normalizeLexicon(lexicon);
    let optionInLexicon = transformedLexicon.options[option];
    if (optionInLexicon) {
        let groupOfOption = transformedLexicon.options[option].group;
        let groupInLexicon = transformedLexicon.groups.find(group => group.code === groupOfOption);
        if (groupInLexicon) {
            let action = TYPES.SET_RULE_ACTION;
            let optionInSourceOptions = sourceOptions.indexOf(option) > -1;
            if (optionInSourceOptions && !groupInLexicon.exclusive && !groupInLexicon.required) {
                action = TYPES.UNSET_RULE_ACTION;
            }
            return toggleOptionRecursively({
                options: sourceOptions,
                lexicon: transformedLexicon,
                action,
                option
            });
        }
    }
    return sourceOptions;
}

/* eslint-disable no-param-reassign */
function toggleOptions({options = [], lexicon = {}, actions = []} = {}) {
    return actions.reduce((targetOptions, action) => {
        targetOptions = toggleOption({
            options: targetOptions,
            option: action.target,
            action: action.action,
            lexicon
        });
        return targetOptions;
    }, options);
}

/* eslint-disable no-param-reassign */
function toggleOptionRecursively({options = [], option = '', lexicon = {}, action = TYPES.SET_RULE_ACTION} = {}) {
    if (!lexicon.options[option]) {
        return options;
    }
    if (TYPES.SET_RULE_ACTION === action) {
        if (options.indexOf(option) > -1) {
            return options;
        }
        options.push(option);
    } else if (TYPES.UNSET_RULE_ACTION === action) {
        if (options.indexOf(option) === -1) {
            return options;
        }
        options = without(options, option);
    }
    let optionRules = Lexicon.getOptionRules({
        option,
        type: ((action === TYPES.SET_RULE_ACTION) ? TYPES.SET_OPTION_TRIGGERD_RULES : TYPES.UNSET_OPTION_TRIGGERD_RULES),
        lexicon
    });
    // See the definations from https://confluence.teslamotors.com/display/OC/Understanding+the+Options+Warehouse+Data
    if (optionRules) {
        optionRules.forEach(optionRule => {
            let {action, target, operator, operatorConditions, conditionCode, conditionState} = optionRule;
            let applyRuleFlag = true;
            if (conditionCode && conditionState) {
                if (TYPES.UNSET_RULE_ACTION === conditionState && options.indexOf(conditionCode) === -1) {
                    applyRuleFlag = true;
                } else if (TYPES.SET_RULE_ACTION === conditionState && options.indexOf(conditionCode) > -1) {
                    applyRuleFlag = true;
                } else {
                    applyRuleFlag = false;
                }
            }
            if (operator) {
                if (TYPES.RULE_OPERATOR_AND === operator) {
                    applyRuleFlag = true;
                    operatorConditions.forEach(({conditionCode, conditionState}) => {
                        if (conditionState === TYPES.UNSET_RULE_ACTION && options.indexOf(conditionCode) > -1) {
                            applyRuleFlag = false;
                        } else if (conditionState === TYPES.SET_RULE_ACTION && options.indexOf(conditionCode) === -1) {
                            applyRuleFlag = false;
                        }
                    });
                } else if (TYPES.RULE_OPERATOR_OR === operator) {
                    applyRuleFlag = false;
                    operatorConditions.forEach(({conditionCode, conditionState}) => {
                        if (conditionState === TYPES.UNSET_RULE_ACTION && options.indexOf(conditionCode) === -1) {
                            applyRuleFlag = true;
                        } else if (conditionState === TYPES.SET_RULE_ACTION && options.indexOf(conditionCode) > -1) {
                            applyRuleFlag = true;
                        }
                    });
                }
            }
            if (applyRuleFlag) {
                options = toggleOptionRecursively({
                    options,
                    lexicon,
                    option: target,
                    action
                });
            }
        });
    }
    return options;
}
