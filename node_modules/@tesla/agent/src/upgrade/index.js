const intersection = require('lodash/intersection');
const TYPES = require('../utils/types');
const Validator = require('../validator');
const Lexicon = require('../utils/lexicon');

module.exports = {
    upgrade,
    getEligibleUpgradableOptions
};

/* eslint-disable no-param-reassign */
function upgrade(optionList = [], lexicon = {}) {
    let normalizedLexicon = Lexicon.normalizeLexicon(lexicon);
    const validationResult = Validator.validateRules(optionList, normalizedLexicon);
    if (validationResult.success) {
        let upgradableOptionList = combination(getEligibleUpgradableOptions(optionList, normalizedLexicon));
        let potentialUpgradedConfigurationList = upgradableOptionList.reduce((upgradedConfigurationList, upgradableOptions) => {
            let upgradedConfiguration = upgradableOptions.reduce((options, upgradableOption) => {
                options = Validator.toggleOption({
                    options,
                    option: upgradableOption,
                    lexicon: normalizedLexicon
                });
                return options;
            }, optionList);
            upgradedConfigurationList.push({
                'upgradedOptions': upgradedConfiguration,
                'sourceOptions': optionList,
                upgradableOptions
            });
            return upgradedConfigurationList;
        }, []);
        return {
            success: true,
            data: potentialUpgradedConfigurationList
        };
    }
    validationResult.code = TYPES.UPGRADE_RESULT_TYPE_INVALID_CONFIGURATION;
    return validationResult;
}

function getEligibleUpgradableOptions(optionList = [], lexicon = {}) {
    let upgradableOptions = [];
    if (lexicon.metadata && lexicon.metadata.post_mfg_mutations) {
        let upgrades = lexicon.metadata.post_mfg_mutations;
        upgradableOptions = Object.keys(upgrades).filter(upgradableOption => {
            let {type, mutation, requirement_relationship} = upgrades[upgradableOption];
            if (TYPES.UPGRADE_TYPE_NOT_AVAILABLE !== type && optionList.indexOf(upgradableOption) === -1) {
                if (Array.isArray(mutation) && mutation.length) {
                    if (TYPES.RULE_OPERATOR_AND === requirement_relationship) {
                        return intersection(mutation, optionList).length === mutation.length;
                    } else if (TYPES.RULE_OPERATOR_OR === requirement_relationship) {
                        return intersection(mutation, optionList).length;
                    }
                } else {
                    return true;
                }
            }
            return false;
        });
    }
    return upgradableOptions;
}

function combination(set) {
    let binary = [];
    let output = [];
    let totalSubSets = Math.pow(2, set.length);
    /* eslint-disable no-plusplus */
    for (let i = 0; i < totalSubSets; i++) {
        binary.push(i.toString(2));
    }
    binary.forEach(element => {
        element = element.split('').reverse();
        let sub = [];
        element.forEach((item, index) => {
            if (item === '1') {
                sub.push(set[index]);
            }
        });
        if (sub.length) {
            output.push(sub);
        }
    });
    return output;
}
