const Rx = require('rxjs/Rx');
const difference = require('lodash/difference');

const Configuration = require('../utils/configuration');
const Lexicon = require('../utils/lexicon');
const TYPES = require('../utils/types');
const Utils = require('../utils/index');
const Validator = require('../validator');

module.exports = {
    transform,
    transformPromise,
    transformObservable$,
    transformWithRules,
    applyRule,
    validateRule,
    mapOptions
};

const TRANSFORM_MKT_TO_MFG_TYPES = [
    TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING,
    TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_BY_VMID,
    TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_WITH_CUSTOM_PRICING,
    TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_BY_VMID_WITH_CUSTOM_PRICING
];

function transform(configurations = [], transformCallback, type = TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING) {
    transformObservable$(configurations, type).subscribe(
        result => {
            if (transformCallback) {
                transformCallback(result);
            }
        }
    );
}

function transformPromise(configurations = [], type = TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING) {
    return transformObservable$(configurations, type).toPromise();
}

function transformObservable$(configurations = [], type = TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING) {
    let normalizedConfigurations = Utils.normalizeInput(configurations);
    return Rx.Observable.from(normalizedConfigurations)
               .concatMap(configuration => transformConfigurationObservable$(configuration, type))
               .toArray()
               .map(result => Utils.normalizeOutput(configurations, result));
}

function transformConfigurationObservable$(configuration = {}, type = TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING) {
    return Lexicon.getLexicon$(configuration, type)
        .map((lexicons = []) => transformWithRules(configuration, lexicons, type))
        .map(result => Utils.httpExceptionTransform(result));
}

function transformWithRules(configuration, lexicons = [], type = TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING) {
    let sourceOptionList = Configuration.getOptionList(configuration);
    if (!Array.isArray(lexicons) || lexicons.indexOf(TYPES.EXCEPTION_HTTP_REQUEST) > -1) {
        return {
            success: false,
            code: TYPES.EXCEPTION_HTTP_REQUEST,
            message: 'Please provide valid transformation lexicons array [marketing, transformation, manufacturing]'
        };
    } else if (TRANSFORM_MKT_TO_MFG_TYPES.indexOf(type) > -1) {
        let marketValidationResult = Validator.validateRulesAndPrice(configuration, type, lexicons[TYPES.TRANSFORM_LEXICON_MARKETING]);
        if (marketValidationResult.success) {
            return transfromFromMktToMfg(sourceOptionList, lexicons);
        }
        return marketValidationResult;
    }
    return transfromFromMfgToMkt(sourceOptionList, lexicons, type);
}

function mapOptions(sourceOptionList, lexicons = [], type = TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING) {
    if (TRANSFORM_MKT_TO_MFG_TYPES.indexOf(type) > -1) {
        return transfromFromMktToMfg(sourceOptionList, lexicons);
    }
    return transfromFromMfgToMkt(sourceOptionList, lexicons);
}

/* eslint-disable no-param-reassign */
function transfromFromMfgToMkt(sourceOptionList, lexicons) {
    let manufacturingValidationResult = Validator.validateRules(sourceOptionList, lexicons[TYPES.TRANSFORM_LEXICON_MANUFACTURING]);
    if (manufacturingValidationResult.success) {
        let transformingLexicon = Lexicon.normalizeLexiconForManufacturingToMarketing(lexicons[TYPES.TRANSFORM_LEXICON]);
        let marketingLexicon = Lexicon.normalizeLexicon(lexicons[TYPES.TRANSFORM_LEXICON_MARKETING]);
        let optionsInTransformingLexicon = transformingLexicon.options;
        let mappedOptions = Object.keys(optionsInTransformingLexicon).reduce((targetOptions, option) => {
            let initRulesOfOption = {
                [TYPES.SET_RULE_ACTION]: [],
                [TYPES.UNSET_RULE_ACTION]: []
            };
            let filteredRulesOfOption = optionsInTransformingLexicon[option].set_rules.reduce((rules, {action, target}) => {
                rules[action].push(target);
                return rules;
            }, initRulesOfOption);
            let isRequiredOptionsAllSet = difference(filteredRulesOfOption[TYPES.SET_RULE_ACTION], sourceOptionList).length === 0;
            let isExclusiveOptionsAllUnset = difference(filteredRulesOfOption[TYPES.UNSET_RULE_ACTION], difference(filteredRulesOfOption[TYPES.UNSET_RULE_ACTION], sourceOptionList)).length === 0;
            if (isRequiredOptionsAllSet && isExclusiveOptionsAllUnset) {
                targetOptions = Validator.toggleOption({
                    options: targetOptions,
                    lexicon: marketingLexicon,
                    action: TYPES.SET_RULE_ACTION,
                    option
                });
            }
            return targetOptions;
        }, marketingLexicon.base_configuration);

        return {
            data: {
                market: marketingLexicon.market,
                language: marketingLexicon.language,
                product: marketingLexicon.product,
                name: marketingLexicon.name,
                effectiveDate: marketingLexicon.effective_date,
                options: mappedOptions.map(option => ({
                    code: option,
                    price: marketingLexicon.options[option].price
                }))
            },
            success: true,
            code: TYPES.TRANSFORM_RESULT_TYPE_SUCCESS
        };
    }
    return manufacturingValidationResult;
}

function transfromFromMktToMfg(sourceOptionList, lexicons) {
    let marketValidationResult = Validator.validateRules(sourceOptionList, lexicons[TYPES.TRANSFORM_LEXICON_MARKETING]);
    if (marketValidationResult.success) {
        let transformingLexicon = Lexicon.normalizeLexicon(lexicons[TYPES.TRANSFORM_LEXICON]);
        let manufacturingLexicon = Lexicon.normalizeLexicon(lexicons[TYPES.TRANSFORM_LEXICON_MANUFACTURING]);
        let mappedOptionsWithRegion = mapRegionRelatedRules(lexicons[TYPES.TRANSFORM_LEXICON_MARKETING].market, transformingLexicon, manufacturingLexicon);
        let mappedOptions = mapOptionsWithRules(mappedOptionsWithRegion, sourceOptionList, transformingLexicon, manufacturingLexicon);
        return {
            data: mappedOptions,
            success: true,
            code: TYPES.TRANSFORM_RESULT_TYPE_SUCCESS
        };
    }
    return marketValidationResult;
}

function mapRegionRelatedRules(market = 'US', transformingLexicon, manufacturingLexicon) {
    return Validator.toggleOptions({
        options: manufacturingLexicon.base_configuration,
        lexicon: manufacturingLexicon,
        actions: transformingLexicon.region[market].set_rules
    });
}

/* eslint-disable no-param-reassign */
function mapOptionsWithRules(targetOptionList = [], sourceOptionList = [], transformingLexicon, manufacturingLexicon) {
    return sourceOptionList.reduce((targetOptions, sourceOption) => {
        let transformingRuleOfOption = transformingLexicon.options[sourceOption];
        if (transformingRuleOfOption && transformingRuleOfOption.set_rules) {
            transformingRuleOfOption.set_rules.forEach(transformingRule => {
                targetOptions = applyRule(targetOptions, sourceOptionList, transformingRule, manufacturingLexicon);
            });
        }
        return targetOptions;
    }, targetOptionList);
}

/* eslint-disable no-param-reassign */
function applyRule(targetOptionList, sourceOptionList, transformingRule, manufacturingLexicon) {
    if (validateRule(targetOptionList, sourceOptionList, transformingRule)) {
        targetOptionList = Validator.toggleOption({
            options: targetOptionList,
            lexicon: manufacturingLexicon,
            option: transformingRule.target,
            action: transformingRule.action
        });
    }
    return targetOptionList;
}

function validateRule(targetOptionList, sourceOptionList, transformingRule) {
    let {operator, operatorConditions, conditionCode, conditionState} = transformingRule;
    let isRuleValid = true;
    if (conditionCode && conditionState) {
        // For set rule, if the conditionCode is missing from target/source option list, we won't apply the rule
        if (TYPES.SET_RULE_ACTION === conditionState && targetOptionList.indexOf(conditionCode) === -1 && sourceOptionList.indexOf(conditionCode) === -1) {
            isRuleValid = false;
        // For unset rule, if the conditionCode exists in target/source option list, we won't apply the rule
        } else if (conditionState === TYPES.UNSET_RULE_ACTION && (targetOptionList.indexOf(conditionCode) > -1 || sourceOptionList.indexOf(conditionCode) > -1)) {
            isRuleValid = false;
        }
    }
    if (operator) {
        if (TYPES.RULE_OPERATOR_AND === operator) {
            isRuleValid = true;
            operatorConditions.forEach(({conditionCode, conditionState}) => {
                // For unset rule, if any of the conditionCode exists in target/source option list, we won't apply the rule
                if (conditionState === TYPES.UNSET_RULE_ACTION && (targetOptionList.indexOf(conditionCode) > -1 || sourceOptionList.indexOf(conditionCode) > -1)) {
                    isRuleValid = false;
                // For set rule, if any of the conditionCode is missing from target/source option list, we won't apply the rule
                } else if (conditionState === TYPES.SET_RULE_ACTION && targetOptionList.indexOf(conditionCode) === -1 && sourceOptionList.indexOf(conditionCode) === -1) {
                    isRuleValid = false;
                }
            });
        } else if (TYPES.RULE_OPERATOR_OR === operator) {
            isRuleValid = false;
            operatorConditions.forEach(({conditionCode, conditionState}) => {
                // For unset rule, if any of the conditionCode is missing in target/source option list, we will apply the rule
                if (conditionState === TYPES.UNSET_RULE_ACTION && (targetOptionList.indexOf(conditionCode) === -1 || sourceOptionList.indexOf(conditionCode) === -1)) {
                    isRuleValid = true;
                // For set rule, if any of the conditionCode exists in target/source option list, we will apply the rule
                } else if (conditionState === TYPES.SET_RULE_ACTION && (targetOptionList.indexOf(conditionCode) > -1 || sourceOptionList.indexOf(conditionCode) > -1)) {
                    isRuleValid = true;
                }
            });
        }
    }
    return isRuleValid;
}
