const uuidv4 = require('uuid/v4');
const Utils = require('./index');
const TYPES = require('./types');
const ENV = require('../env');
const each = require('lodash/each');
const groupBy = require('lodash/groupBy');

module.exports = {
    getGroupOfOptions,
    getExclusiveGroups,
    getRequiredGroups,
    getOptionRules,
    getGroupsByProperty,
    normalizeRule,
    getLexicon$,
    normalizeLexicon,
    normalizeLexiconForManufacturingToMarketing
};

function getGroupOfOptions(options = [], lexicon = {}) {
    let optionsInLexicon = lexicon.options;
    return options.reduce((groups, option) => {
        if (optionsInLexicon[option]) {
            groups.push(optionsInLexicon[option].group);
        }
        return groups;
    }, []);
}

function getExclusiveGroups(lexicon) {
    return getGroupsByProperty(lexicon, 'exclusive');
}

function getRequiredGroups(lexicon) {
    return getGroupsByProperty(lexicon, 'required');
}

function getOptionRules({lexicon, option, type}) {
    let rules = [];
    let optionInLexicon = lexicon.options[option];
    if (optionInLexicon && optionInLexicon[type]) {
        rules = optionInLexicon[type] || rules;
    }
    return rules;
}

function getGroupsByProperty(lexicon, property) {
    return lexicon.groups.filter(item => (!item.groups || isNotUIOnlyGroups(item)))
        .filter(item => item[property])
        .map(item => item.code);
}

function normalizeRule(rules = []) {
    let normalizedRules = [];
    let tempRule = {};
    let composedRuleStarted = false;
    rules.forEach(rule => {
        if (rule.operator) {
            if (!composedRuleStarted) {
                tempRule = {
                    operatorConditions: [],
                    action: rule.action,
                    target: rule.target,
                    operator: rule.operator
                };
                composedRuleStarted = true;
            }
            if (rule.operator && composedRuleStarted) {
                tempRule.operatorConditions.push({
                    conditionCode: rule.condition_code,
                    conditionState: rule.condition_state
                });
            }
        } else if (composedRuleStarted) {
            tempRule.operatorConditions.push({
                conditionCode: rule.condition_code,
                conditionState: rule.condition_state
            });
            composedRuleStarted = false;
            normalizedRules.push(tempRule);
        } else if (rule.condition_code) {
            normalizedRules.push({
                action: rule.action,
                target: rule.target,
                conditionCode: rule.condition_code,
                conditionState: rule.condition_state
            });
        } else {
            normalizedRules.push(rule);
        }
    });
    return normalizedRules;
}

function getLexicon$({market, language, model, id}, type, date = '', requestId = uuidv4()) {
    let endpoint = '';
    switch (type) {
    // Validation section
    case TYPES.VALIDATION_TYPE_MARKETING:
    case TYPES.VALIDATION_TYPE_MARKETING_WITH_CUSTOM_PRICING:
        endpoint = `${ENV.OCW_API_HOST}/lexicon/${TYPES.OCW_MARKETING_LEXICON}/${market}/${language}/${model}?date=${date}`;
        break;
    case TYPES.VALIDATION_TYPE_MARKETING_BY_VMID:
    case TYPES.VALIDATION_TYPE_MARKETING_BY_VMID_WITH_CUSTOM_PRICING:
    case TYPES.UPGRADE_LEXICON_MARKETING:
        endpoint = `${ENV.OCW_LBN_HOST}/lexicon/${TYPES.OCW_MARKETING_LEXICON}/${id}`;
        break;
    case TYPES.VALIDATION_TYPE_MANUFACTURING:
    // Here we only have one manufacturing lexicon, so take US/en
        endpoint = `${ENV.OCW_API_HOST}/lexicon/${TYPES.OCW_MANUFACTURING_LEXICON}/US/en/${model}?date=${date}`;
        break;
    case TYPES.VALIDATION_TYPE_MANUFACTURING_BY_VID:
        endpoint = `${ENV.OCW_LBN_HOST}/lexicon/${TYPES.OCW_MANUFACTURING_LEXICON}/${id}`;
        break;
    // Transformation section
    case TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING:
    case TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_WITH_CUSTOM_PRICING:
    case TYPES.TRANSFORM_MANUFACTURING_TO_MARKETING:
        endpoint = `${ENV.OCW_API_HOST}/lexicon/${TYPES.OCW_TRANSFORMATION_LEXICON}/${market}/${language}/${model}?date=${date}`;
        break;
    case TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_BY_VMID:
    case TYPES.TRANSFORM_MARKETING_TO_MANUFACTURING_BY_VMID_WITH_CUSTOM_PRICING:
        endpoint = `${ENV.OCW_LBN_HOST}/lexicon/${TYPES.OCW_TRANSFORMATION_MARKETING_TO_MANUFACTURING_LEXICON}/${id}`;
        break;
    case TYPES.TRANSFORM_MANUFACTURING_TO_MARKETING_BY_VID:
        endpoint = `${ENV.OCW_LBN_HOST}/lexicon/${TYPES.OCW_TRANSFORMATION_MANUFACTURING_TO_MARKETING_LEXICON}/${id}`;
        break;
    // Migration section
    case TYPES.MIGRATION_LEXICON_MARKETING:
        endpoint = `${ENV.OCW_API_HOST}/lexicon/${TYPES.OCW_MARKETING_LEXICON}/${market}/${language}/${model}?date=${date}`;
        break;
    case TYPES.MIGRATION_LEXICON_MANUFACTURING:
    // Here we only have one manufacturing lexicon, so take US/en
        endpoint = `${ENV.OCW_API_HOST}/lexicon/${TYPES.OCW_MANUFACTURING_LEXICON}/US/en/${model}?date=${date}`;
        break;
    // Matching section
    case TYPES.MATCHING_INVENTORY:
        endpoint = `${ENV.OCW_LBN_HOST}/lexicon/${TYPES.OCW_MANUFACTURING_LEXICON}/${id}?context[]=${TYPES.OCW_DEFAULT_CONTEXT}&context[]=${TYPES.OCW_MATCHING_CONTEXT}`;
        break;
    }
    if (!endpoint) {
        console.log('WARNING: Make sure you have provided correct environment informations for Agent');
    }
    console.log(`${requestId} Getting lexicon from ${endpoint} with APIKEY ${ENV.OCW_API_TOKEN}`);

    return Utils.httpGetObservable$(endpoint, {
        headers: {
            'x-api-key': ENV.OCW_API_TOKEN,
            'Cache-Control': 'no-store',
            'X-Request-Id': requestId
        }
    }).map(lexicon => {
        if (Array.isArray(lexicon)) {
            return lexicon.map(lexiconItem => normalizeLexicon(lexiconItem));
        }
        return normalizeLexicon(lexicon);
    });
}

/* eslint-disable no-param-reassign */
function normalizeLexicon(sourceLexicon) {
    sourceLexicon = validateLexicon(sourceLexicon);
    if (sourceLexicon === TYPES.EXCEPTION_HTTP_REQUEST || sourceLexicon.normalized) {
        return sourceLexicon;
    }
    let lexicon = Utils.deepClone(sourceLexicon);
    if (lexicon.groups) {
        lexicon.matching = lexicon.groups.filter(group => group.context === TYPES.OCW_MATCHING_CONTEXT);
        lexicon.groups = lexicon.groups.filter(group => group.context === TYPES.OCW_DEFAULT_CONTEXT && isNotUIOnlyGroups(group) && group.options && group.options.length);
    }
    let groupsInLexicon = lexicon.groups;
    let optionsInLexicon = lexicon.options;
    if (groupsInLexicon) {
        groupsInLexicon.forEach(({code, options}) => {
            if (options) {
                options.forEach(option => {
                    if (lexicon.options[option]) {
                        lexicon.options[option].group = code;
                    }
                });
            }
        });
    }
    if (optionsInLexicon) {
        each(optionsInLexicon, ({set_rules, unset_rules}, optionCode) => {
            lexicon.options[optionCode].set_rules = normalizeRule(set_rules);
            lexicon.options[optionCode].unset_rules = normalizeRule(unset_rules);
        });
    }
    if (!lexicon.metadata) {
        lexicon.metadata = {};
    }
    lexicon.normalized = true;
    return lexicon;
}

// Filter out the conditional / operator rules in transformation lexicon, only keep the rules which target option code must be set when we do mkt => mfg exploding.
function normalizeLexiconForManufacturingToMarketing(sourceLexicon) {
    if (sourceLexicon === TYPES.EXCEPTION_HTTP_REQUEST || sourceLexicon.normalizedForManufacturingToMarketing) {
        return sourceLexicon;
    }
    let lexicon = normalizeLexicon(sourceLexicon);
    let optionsInLexicon = lexicon.options;
    if (optionsInLexicon) {
        each(optionsInLexicon, ({set_rules = []}, optionCode) => {
            // Only keep the rule which target action can't be unset when we do mkt => mft exploding, then we can use them to do the reverse mapping
            let rulesByTarget = groupBy(set_rules, 'target');
            let validTargetOfRules = [];
            Object.keys(rulesByTarget).forEach(target => {
                let rulesByAction = groupBy(rulesByTarget[target], 'action');
                if (rulesByAction[TYPES.SET_RULE_ACTION] && !rulesByAction[TYPES.UNSET_RULE_ACTION]) {
                    validTargetOfRules.push(target);
                } else if (!rulesByAction[TYPES.SET_RULE_ACTION] && rulesByAction[TYPES.UNSET_RULE_ACTION]) {
                    validTargetOfRules.push(target);
                }
            });
            lexicon.options[optionCode].set_rules = set_rules.reduce((validRules, rule) => {
                if (validTargetOfRules.indexOf(rule.target) > -1 && !rule.operator && ((!rule.conditionCode && !rule.conditionAction) || (rule.conditionCode === optionCode && rule.conditionState === TYPES.SET_RULE_ACTION))) {
                    validRules.push(rule);
                }
                return validRules;
            }, []);
        });
    }
    lexicon.normalizedForManufacturingToMarketing = true;
    return lexicon;
}

function validateLexicon(lexicon) {
    if (lexicon && lexicon.options) {
        return lexicon;
    }
    return TYPES.EXCEPTION_HTTP_REQUEST;
}

function isNotUIOnlyGroups(group) {
    return !group.groups || (group.groups && Array.isArray(group.groups) && group.groups.length === 0);
}
