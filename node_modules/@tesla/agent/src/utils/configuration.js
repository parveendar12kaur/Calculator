module.exports = {
    getOptionList,
    getAllPossibleConfiguration,
    getSubTotal,
    getMarketingConfiguration,
    getManufacturingConfiguration
};

const PLACE_HOLDER = 'ALL_POSSIBLE_CONFIGURATION_OPTIONAL_OPTION_CODE_OFF_PLACE_HOLDER';

function getOptionList(configuration) {
    return configuration.options ? configuration.options.map(option => option.code) : [];
}

function getAllPossibleConfiguration(lexicon) {
    let optionsMatrixObject = transformLexiconForAllPossibleConfigurations(lexicon);
    return getAllPossibleOptionList(optionsMatrixObject);
}

/* eslint-disable no-plusplus */
/* eslint-disable no-unused-vars */
// Algorithm to handle the combination of 2D array with different row size
function getAllPossibleOptionList({optionsMatrix, iterationMatrix, iterationCursor, iterationLength}) {
    let optionList = [];
    for (let i = 0; i < iterationLength; i++) {
        let emptyList = optionsMatrix.map(item => 0);
        let emptyListLength = optionsMatrix.length;
        for (let j = 0; j < emptyListLength; j++) {
            emptyList[j] = optionsMatrix[j][iterationCursor[j]];
        }
        emptyList = emptyList.filter(item => item !== PLACE_HOLDER);
        iterationCursor[0]++;
        for (let k = 0; k < emptyListLength - 1; k++) {
            if (iterationCursor[k] === iterationMatrix[k]) {
                iterationCursor[k] = 0
                iterationCursor[k + 1]++;
            }
        }
        optionList.push(emptyList);
    }
    return optionList;
}

// Abstraction, transform group/options to a 2D array mathmatical model
function transformLexiconForAllPossibleConfigurations(lexicon) {
    let optionsMatrix = [];
    let iterationMatrix = [];
    let iterationCursor = [];
    let iterationLength = 1;
    let transformedGroups = lexicon.groups.reduce((groups, group) => {
        if (group.required && group.exclusive) {
            groups.push({options: group.options.slice()});
        } else if (!group.required && group.exclusive) {
            let groupOptions = [];
            group.options.forEach(option => {
                groupOptions.push(PLACE_HOLDER);
                groupOptions.push(option);
            });
            groups.push({options: groupOptions});
        } else if (!group.required && !group.exclusive) {
            group.options.forEach(option => {
                groups.push({options: [option, PLACE_HOLDER]});
            });
        } else {
            group.options.forEach(option => {
                groups.push({options: [option]});
            });
        }
        return groups;
    }, []);

    transformedGroups.forEach(group => {
        let groupOptions = group.options;
        let groupOptionsLength = groupOptions.length;
        iterationMatrix.push(groupOptionsLength);
        iterationLength *= groupOptionsLength;
        optionsMatrix.push(groupOptions);
        iterationCursor.push(0);
    });
    return {
        optionsMatrix,
        iterationMatrix,
        iterationCursor,
        iterationLength
    };
}

function getMarketingConfiguration(options = [], lexicon = {}) {
    let optionsObject = options.filter(option => !!lexicon.options[option])
        .map(option => ({
            code: option,
            price: lexicon.options[option].price,
            group: lexicon.options[option].group
        }));
    return {
        market: lexicon.market,
        model: lexicon.product,
        language: lexicon.language,
        effective_date: lexicon.effective_date,
        options: optionsObject,
        sub_total: getSubTotal(options, lexicon)
    };
}

function getManufacturingConfiguration(options = [], lexicon = {}) {
    let optionsObject = options.filter(option => !!lexicon.options[option])
        .map(option => ({
            code: option,
            group: lexicon.options[option].group
        }));
    return {
        market: lexicon.market,
        model: lexicon.product,
        language: lexicon.language,
        effective_date: lexicon.effective_date,
        options: optionsObject
    };
}

/* eslint-disable no-param-reassign */
function getSubTotal(options = [], lexicon = {}) {
    if (!lexicon.options) {
        return 'Something wrong with the lexicon you given, we can\'t get the total price';
    }
    return options.reduce((sum, option) => {
        if (lexicon.options[option]) {
            sum += (parseInt(lexicon.options[option].price, 10) || 0);
        }
        return sum;
    }, 0);
}
