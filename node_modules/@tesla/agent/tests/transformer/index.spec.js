const path = require('path');
const chai = require('chai');
const expect = chai.expect;
const Axios = require('axios');
const AxiosMockAdapter = require('axios-mock-adapter');

const utils = require(path.resolve(__dirname, '../utils'));
const ENV = require(path.resolve(__dirname, '../../dist/env'));
const Transformer = require(path.resolve(__dirname, '../../dist/transformer/'));
const Agent = require(path.resolve(__dirname, '../../dist'));

describe('Transformer', () => {
    let mock;

    beforeEach(() => {
        mock = new AxiosMockAdapter(Axios);
        mock.onGet(ENV.TRANSFORM_LEXICON).reply(200, utils.generateMarketingToManufacturingLexicon('AU'));
    });

    afterEach(() => {
        mock.restore();
    });

    describe('transform from marketing to manufacturing ', () => {
        it('should transform marketing configuration to manufacturing option list by given lexicon', (done) => {
            let sourceOptionList = ['$AAAA'];
            let transformedOptionList = ['AAAA', 'DDDD', 'FFFF', 'COAU', 'REAP'];
            Agent.transform(utils.generateConfigurationByOptionList(sourceOptionList), function(response) {
                expect(JSON.stringify(response.data.sort())).to.equal(JSON.stringify(transformedOptionList.sort()));
                done();
            });
        });

        it('should transform marketing configuration to manufacturing option list by given lexicon', (done) => {
            let sourceOptionList = ['$BBBB'];
            let transformedOptionList = ['BBBB', 'CCCC', 'FFFF', 'COAU', 'REAP'];
            Agent.transform(utils.generateConfigurationByOptionList(sourceOptionList), function(response) {
                expect(JSON.stringify(response.data.sort())).to.equal(JSON.stringify(transformedOptionList.sort()));
                done();
            });
        });

        it('should transform marketing configuration to manufacturing option list by given lexicon', (done) => {
            let sourceOptionList = ['$AAAA', '$FFFF'];
            let transformedOptionList = ['AAAA', 'DDDD', 'FFFF', 'IIII', 'COAU', 'REAP'];
            Agent.transform(utils.generateConfigurationByOptionList(sourceOptionList), function(response) {
                expect(JSON.stringify(response.data.sort())).to.equal(JSON.stringify(transformedOptionList.sort()));
                done();
            });
        });

        it('should transform marketing configuration to manufacturing option list by given lexicon', (done) => {
            let sourceOptionList = ['$AAAA', '$GGGG'];
            let transformedOptionList = ['AAAA', 'DDDD', 'GGGG', 'JJJJ', 'KKKK', 'COAU', 'REAP'];
            Agent.transform(utils.generateConfigurationByOptionList(sourceOptionList), function(response) {
                expect(JSON.stringify(response.data.sort())).to.equal(JSON.stringify(transformedOptionList.sort()));
                done();
            });
        });

        it('should return false', (done) => {
            let sourceOptionList = ['$AAAA', '$BBBB'];
            Agent.transform(utils.generateConfigurationByOptionList(sourceOptionList), function(response) {
                expect(response.success).to.equal(false);
                done();
            });
        });

        it('should transform marketing configurations to manufacturing option list by given lexicon', (done) => {
            let sourceOptionList = ['$AAAA','$EEEE'];
            let transformedOptionList = ['AAAA', 'EEEE', 'FFFF', 'COAU', 'REAP'];
            Agent.transformObservable$([
                    utils.generateConfigurationByOptionList(sourceOptionList),
                    utils.generateConfigurationByOptionList(sourceOptionList)
                ])
                .subscribe(response => {
                    expect(JSON.stringify(response[0].data.sort())).to.equal(JSON.stringify(transformedOptionList.sort()));
                    expect(JSON.stringify(response[1].data.sort())).to.equal(JSON.stringify(transformedOptionList.sort()));
                    done();
                });
        });
    });

    describe('transform from manufacturing to marketing ', () => {
        it('should transform marketing configuration to manufacturing option list by given lexicon', (done) => {
            let transformedOptionList = ['$AAAA', '$FFFF'];
            let sourceOptionList = ['AAAA', 'DDDD', 'FFFF', 'COAU', 'REAP'];
            Agent.transform(utils.generateConfigurationByOptionList(sourceOptionList), function(response) {
                expect(JSON.stringify(utils.getOptionListFromMappedOptionsResult(response))).to.equal(JSON.stringify(transformedOptionList.sort()));
                done();
            }, Agent.TYPES.TRANSFORM_MANUFACTURING_TO_MARKETING);
        });

        it('should transform marketing configuration to manufacturing option list by given lexicon', (done) => {
            let transformedOptionList = ['$BBBB', '$FFFF'];
            let sourceOptionList = ['BBBB', 'CCCC', 'FFFF', 'COAU', 'REAP'];
            Agent.transform(utils.generateConfigurationByOptionList(sourceOptionList), function(response) {
                expect(JSON.stringify(utils.getOptionListFromMappedOptionsResult(response))).to.equal(JSON.stringify(transformedOptionList.sort()));
                done();
            }, Agent.TYPES.TRANSFORM_MANUFACTURING_TO_MARKETING);
        });

        it('should transform marketing configuration to manufacturing option list by given lexicon', (done) => {
            let transformedOptionList = ['$AAAA', '$FFFF'];
            let sourceOptionList = ['AAAA', 'DDDD', 'FFFF', 'IIII', 'COAU', 'REAP'];
            Agent.transform(utils.generateConfigurationByOptionList(sourceOptionList), function(response) {
                expect(JSON.stringify(utils.getOptionListFromMappedOptionsResult(response))).to.equal(JSON.stringify(transformedOptionList.sort()));
                done();
            }, Agent.TYPES.TRANSFORM_MANUFACTURING_TO_MARKETING);
        });

        it('should transform marketing configuration to manufacturing option list by given lexicon', (done) => {
            let transformedOptionList = ['$AAAA', '$GGGG'];
            let sourceOptionList = ['AAAA', 'DDDD', 'GGGG', 'JJJJ', 'KKKK', 'COAU', 'REAP'];
            Agent.transform(utils.generateConfigurationByOptionList(sourceOptionList), function(response) {
                expect(JSON.stringify(utils.getOptionListFromMappedOptionsResult(response))).to.equal(JSON.stringify(transformedOptionList.sort()));
                done();
            }, Agent.TYPES.TRANSFORM_MANUFACTURING_TO_MARKETING);
        });

        it('should transform marketing configurations to manufacturing option list by given lexicon', (done) => {
            let transformedOptionList = ['$AAAA','$EEEE', '$FFFF'];
            let sourceOptionList = ['AAAA', 'EEEE', 'FFFF', 'COAU', 'REAP'];
            Agent.transformObservable$([
                    utils.generateConfigurationByOptionList(sourceOptionList),
                    utils.generateConfigurationByOptionList(sourceOptionList)
                ], Agent.TYPES.TRANSFORM_MANUFACTURING_TO_MARKETING)
                .subscribe(response => {
                    expect(JSON.stringify(utils.getOptionListFromMappedOptionsResult(response[0]))).to.equal(JSON.stringify(transformedOptionList.sort()));
                    expect(JSON.stringify(utils.getOptionListFromMappedOptionsResult(response[1]))).to.equal(JSON.stringify(transformedOptionList.sort()));
                    done();
                });
        });
    });

    describe('transformPromise method ', () => {
        it('should transform marketing configuration to manufacturing option list by given lexicon', (done) => {
            let sourceOptionList = ['$AAAA','$EEEE'];
            let transformedOptionList = ['AAAA', 'EEEE', 'FFFF', 'COAU', 'REAP'];
            Agent.transformPromise(utils.generateConfigurationByOptionList(sourceOptionList))
                .then(response => {
                    expect(JSON.stringify(response.data.sort())).to.equal(JSON.stringify(transformedOptionList.sort()));
                    done();
            });
        });
    });

    describe('validRule method ', () => {
        it('should return correct response if the conditional rule is valid or not', () => {
            let targetOptionList = ['COUS', 'RENA'];
            let sourceOptionList = ['$AAAA', '$BBBB', '$CCCC'];
            let transformingRule = {
                action: 'set',
                target: 'AAAA'
            };
            expect(Transformer.validateRule(targetOptionList, sourceOptionList, transformingRule)).to.equal(true);
            transformingRule = {
                action: 'set',
                target: 'AAAA',
                conditionState: 'set',
                conditionCode: '$DDDD'
            };
            expect(Transformer.validateRule(targetOptionList, sourceOptionList, transformingRule)).to.equal(false);
            transformingRule = {
                action: 'set',
                target: 'AAAA',
                conditionState: 'set',
                conditionCode: '$CCCC'
            };
            expect(Transformer.validateRule(targetOptionList, sourceOptionList, transformingRule)).to.equal(true);
            transformingRule = {
                action: 'set',
                target: 'AAAA',
                conditionState: 'set',
                conditionCode: 'COUS'
            };
            expect(Transformer.validateRule(targetOptionList, sourceOptionList, transformingRule)).to.equal(true);
            transformingRule = {
                action: 'set',
                target: 'AAAA',
                conditionState: 'set',
                conditionCode: 'RENA'
            };
            expect(Transformer.validateRule(targetOptionList, sourceOptionList, transformingRule)).to.equal(true);
        });

        it('should return correct response if the operational rule is valid or not', () => {
            let targetOptionList = ['COUS', 'RENA'];
            let sourceOptionList = ['$AAAA', '$BBBB', '$CCCC'];
            let transformingRule = {
                action: 'set',
                target: 'AAAA',
                operator: 'and',
                operatorConditions: [{
                    conditionCode: '$AAAA',
                    conditionState: 'set'
                },{
                    conditionCode: '$BBBB',
                    conditionState: 'set'
                },{
                    conditionCode: '$CCCC',
                    conditionState: 'set'
                }]
            };
            expect(Transformer.validateRule(targetOptionList, sourceOptionList, transformingRule)).to.equal(true);
            transformingRule = {
                action: 'set',
                target: 'AAAA',
                operator: 'or',
                operatorConditions: [{
                    conditionCode: '$AAAA',
                    conditionState: 'set'
                },{
                    conditionCode: '$BBBB',
                    conditionState: 'set'
                },{
                    conditionCode: '$CCCC',
                    conditionState: 'set'
                }]
            };
            expect(Transformer.validateRule(targetOptionList, sourceOptionList, transformingRule)).to.equal(true);
            transformingRule = {
                action: 'set',
                target: 'AAAA',
                operator: 'and',
                operatorConditions: [{
                    conditionCode: '$AAAA',
                    conditionState: 'set'
                },{
                    conditionCode: '$BBBB',
                    conditionState: 'set'
                },{
                    conditionCode: 'COUS',
                    conditionState: 'set'
                }]
            };
            expect(Transformer.validateRule(targetOptionList, sourceOptionList, transformingRule)).to.equal(true);
            transformingRule = {
                action: 'set',
                target: 'AAAA',
                operator: 'or',
                operatorConditions: [{
                    conditionCode: '$AAAA',
                    conditionState: 'set'
                },{
                    conditionCode: '$BBBB',
                    conditionState: 'set'
                },{
                    conditionCode: 'COUS',
                    conditionState: 'set'
                }]
            };
            expect(Transformer.validateRule(targetOptionList, sourceOptionList, transformingRule)).to.equal(true);
            transformingRule = {
                action: 'set',
                target: 'AAAA',
                operator: 'and',
                operatorConditions: [{
                    conditionCode: '$AAAA',
                    conditionState: 'set'
                },{
                    conditionCode: '$FFFF',
                    conditionState: 'set'
                },{
                    conditionCode: 'COUS',
                    conditionState: 'set'
                }]
            };
            expect(Transformer.validateRule(targetOptionList, sourceOptionList, transformingRule)).to.equal(false);
            transformingRule = {
                action: 'set',
                target: 'AAAA',
                operator: 'or',
                operatorConditions: [{
                    conditionCode: '$AAAA',
                    conditionState: 'set'
                },{
                    conditionCode: '$FFFF',
                    conditionState: 'set'
                },{
                    conditionCode: 'COUS',
                    conditionState: 'set'
                }]
            };
            expect(Transformer.validateRule(targetOptionList, sourceOptionList, transformingRule)).to.equal(true);
            transformingRule = {
                action: 'set',
                target: 'AAAA',
                operator: 'or',
                operatorConditions: [{
                    conditionCode: '$AAAA',
                    conditionState: 'set'
                },{
                    conditionCode: '$FFFF',
                    conditionState: 'unset'
                },{
                    conditionCode: 'COUS',
                    conditionState: 'set'
                }]
            };
            expect(Transformer.validateRule(targetOptionList, sourceOptionList, transformingRule)).to.equal(true);
            transformingRule = {
                action: 'set',
                target: 'AAAA',
                operator: 'and',
                operatorConditions: [{
                    conditionCode: '$AAAA',
                    conditionState: 'set'
                },{
                    conditionCode: '$FFFF',
                    conditionState: 'unset'
                },{
                    conditionCode: 'COUS',
                    conditionState: 'set'
                }]
            };
            expect(Transformer.validateRule(targetOptionList, sourceOptionList, transformingRule)).to.equal(true);
            transformingRule = {
                action: 'set',
                target: 'AAAA',
                operator: 'and',
                operatorConditions: [{
                    conditionCode: '$AAAA',
                    conditionState: 'set'
                },{
                    conditionCode: '$FFFF',
                    conditionState: 'unset'
                },{
                    conditionCode: 'COUS',
                    conditionState: 'unset'
                }]
            };
            expect(Transformer.validateRule(targetOptionList, sourceOptionList, transformingRule)).to.equal(false);
        });
    });
});
