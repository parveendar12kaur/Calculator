const path = require('path');
const chai = require('chai');
const Rx = require('rxjs/rx');
const expect = chai.expect;
const Axios = require('axios');
const AxiosMockAdapter = require('axios-mock-adapter');

const utils = require(path.resolve(__dirname, '../utils'));
const ENV = require(path.resolve(__dirname, '../../dist/env'));
const Agent = require(path.resolve(__dirname, '../../dist'));
const Migration = require(path.resolve(__dirname, '../../dist/migration'))

const UPGRADE_LEXICONS = require(path.resolve(__dirname, '../fixtures/migrationUpgradeLexicon.json'));
const DOWNGRADE_LEXICONS = require(path.resolve(__dirname, '../fixtures/migrationDowngradeLexicon.json'));

describe('Migration', () => {
    describe('Upgrade Configuration', () => {
    	it("should replace $AAAA with $AAA1", () => {
    		expectMigrationResult(utils.generateConfigurationByOptionList(['$AAAA','$DDDD','$GGGG','$LLLL']), UPGRADE_LEXICONS, ['$AAA1', '$DDDD', '$GGGG', '$LLLL', '$MMMM']);
    	});

		it("should replace $AAAA with $AAA1 and $KKKK with $LLLL", () => {
    		expectMigrationResult(utils.generateConfigurationByOptionList(['$AAAA','$DDDD','$GGGG','$KKKK']), UPGRADE_LEXICONS, ['$AAA1', '$DDDD', '$GGGG', '$LLLL', '$MMMM']);
    	});

    	it("should do nothing except appending the new option code", () => {
    		expectMigrationResult(utils.generateConfigurationByOptionList(['$BBBB','$DDDD','$GGGG','$LLLL']), UPGRADE_LEXICONS, ['$BBBB', '$DDDD', '$GGGG', '$LLLL', '$MMMM']);
    	});

    	it("should remove the dis-continued option codes automatically", () => {
    		expectMigrationResult(utils.generateConfigurationByOptionList(['$BBBB','$DDDD','$EEEE', '$GGGG','$LLLL']), UPGRADE_LEXICONS, ['$BBBB', '$DDDD', '$GGGG', '$LLLL', '$MMMM']);
    		expectMigrationResult(utils.generateConfigurationByOptionList(['$BBBB','$DDDD','$FFFF', '$GGGG','$LLLL']), UPGRADE_LEXICONS, ['$BBBB', '$DDDD', '$GGGG', '$LLLL', '$MMMM']);
    	});

        it("should detect the invalid configuration before migration", () => {
            let migrationResult = Agent.migrate(utils.generateConfigurationByOptionList(['$BBBB']), UPGRADE_LEXICONS[0], UPGRADE_LEXICONS[1]);
            expect(migrationResult.success).to.equal(false);
        });
    });

    xdescribe('Downgrade Configuration', () => {
        it("should replace $AAA1 with $AAAA and $LLLL with $KKKK", () => {
            expectMigrationResult(utils.generateConfigurationByOptionList(['$AAA1', '$DDDD', '$GGGG', '$LLLL', '$MMMM']), DOWNGRADE_LEXICONS, ['$AAAA', '$DDDD', '$GGGG', '$KKKK']);
        });

        it("should do nothing except removing the new option code", () => {
            expectMigrationResult(utils.generateConfigurationByOptionList(['$BBBB', '$DDDD', '$GGGG', '$LLLL', '$MMMM']), DOWNGRADE_LEXICONS, ['$BBBB', '$DDDD', '$GGGG', '$LLLL']);
        });

        it("should reverse the dis-continued option codes automatically", () => {
            expectMigrationResult(utils.generateConfigurationByOptionList(['$AAA1', '$DDDD', '$GGGG', '$LLLL', '$MMMM']), DOWNGRADE_LEXICONS, ['$AAAA', '$DDDD', '$GGGG', '$KKKK']);
            expectMigrationResult(utils.generateConfigurationByOptionList(['$BBBB', '$DDDD', '$GGGG', '$LLLL', '$MMMM']), DOWNGRADE_LEXICONS, ['$BBBB', '$DDDD', '$GGGG', '$LLLL']);
        });
    });

    describe('Crosscountry Migration', () => {
        it("should catch unsupported cross-country migration request", () => {
            let newMigrationLexicon = JSON.parse(JSON.stringify(UPGRADE_LEXICONS));
            newMigrationLexicon[1].market = 'AU';
            let migrationResult = Agent.migrate(utils.generateConfigurationByOptionList(['$BBBB','$DDDD','$GGGG','$LLLL']), newMigrationLexicon[0], newMigrationLexicon[1]);
            expect(migrationResult.success).to.equal(false);
            expect(migrationResult.code).to.equal(Agent.TYPES.MIGRATION_RESULT_TYPE_UNSUPPORTED_MIGRATION);
        });
    });

    xdescribe('Reverse upgrade lexicon', () => {
        it("should works good", () => {
            let dummyMigrationLexicon = [
                {
                    "comments": "New Lexicon Release at timestamp 1502226573007, this migrations array should sorted by created timestamp ASC",
                    "options": {
                        "$AAAA": {
                            "unset_rules": [
                                {
                                    "action": "unset",
                                    "target": "$AAAA"
                                },
                                {
                                    "action": "set",
                                    "target": "$AAA1"
                                }
                            ],
                            "set_rules": [],
                            "comments": "swap $AAAA to $AAA1 in new lexicon"
                        }
                    },
                    "effective_date": "2017-07-21T22:51:35.501Z"
                },
                {
                    "comments": "New Lexicon Release at timestamp 1502236573007, this migrations array should sorted by created timestamp ASC",
                    "options": {
                        "$AAA1": {
                            "set_rules": [
                                {
                                    "action": "unset",
                                    "target": "$KKKK"
                                },
                                {
                                    "action": "set",
                                    "target": "$LLLL"
                                }
                            ],
                            "unset_rules": [
                            ],
                            "comments": "Update $AAA1's require/exclude rules in new lexicon"
                        }
                    },
                    "effective_date": "2017-07-21T22:51:35.501Z"
                }
            ];
            let transformedMigrationLexicon = Migration.transformMigrationLexiconForDowngrade(dummyMigrationLexicon);
            console.log(JSON.stringify(transformedMigrationLexicon));
            expect(transformedMigrationLexicon[0]).to.equal(false);
        });
    });
});

function expectMigrationResult(configuration, lexicons, expectedOptionList) {
    expect(JSON.stringify(Agent.migrate(configuration, lexicons[0], lexicons[1]).data.sort())).to.equal(JSON.stringify(expectedOptionList.sort()));
}