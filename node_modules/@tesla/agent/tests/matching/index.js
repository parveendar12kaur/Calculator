const path = require('path');
const chai = require('chai');
const expect = chai.expect;

const Matching = require(path.resolve(__dirname, '../../dist/matching/'));
const MATCHING_LEXICON_DATA = require(path.resolve(__dirname, '../fixtures/matchingLexicon.json'));
const Lexicon = require(path.resolve(__dirname, '../../dist/utils/lexicon'));

describe('Matching', () => {
    describe('matching', () => {
        it('get correct inventoryOptions after matching', () => {
            let customerOptions = ['AAAA', 'CCCC'];
            let inventoryOptions = ['BBBB', 'CCCC', 'FFFF'];
            let matchedInventoryOptions = Matching.matching(customerOptions, inventoryOptions, MATCHING_LEXICON_DATA);
            expectMatchingResult(customerOptions, inventoryOptions, ['AAAA', 'CCCC']);

            customerOptions = ['BBBB', 'CCCC', 'FFFF'];
            inventoryOptions = ['AAAA', 'CCCC'];
            matchedInventoryOptions = Matching.matching(customerOptions, inventoryOptions, MATCHING_LEXICON_DATA);
            expectMatchingResult(customerOptions, inventoryOptions, ['BBBB', 'CCCC', 'FFFF']);

            customerOptions = ['BBBB', 'CCCC', 'FFFF', 'GGGG'];
            inventoryOptions = ['AAAA', 'CCCC'];
            matchedInventoryOptions = Matching.matching(customerOptions, inventoryOptions, MATCHING_LEXICON_DATA);
            expectMatchingResult(customerOptions, inventoryOptions, ['BBBB', 'CCCC', 'FFFF']);

            customerOptions = ['AAAA', 'CCCC', 'GGGG'];
            inventoryOptions = ['BBBB', 'CCCC', 'FFFF'];
            matchedInventoryOptions = Matching.matching(customerOptions, inventoryOptions, MATCHING_LEXICON_DATA);
            expectMatchingResult(customerOptions, inventoryOptions, ['AAAA', 'CCCC']);

            customerOptions = ['AAAA', 'CCCC', 'GGGG'];
            inventoryOptions = ['BBBB', 'DDDD', 'FFFF'];
            matchedInventoryOptions = Matching.matching(customerOptions, inventoryOptions, MATCHING_LEXICON_DATA);
            expectMatchingResult(customerOptions, inventoryOptions, ['AAAA', 'CCCC']);

            customerOptions = ['AAAA', 'DDDD'];
            inventoryOptions = ['BBBB', 'EEEE', 'FFFF', 'GGGG'];
            matchedInventoryOptions = Matching.matching(customerOptions, inventoryOptions, MATCHING_LEXICON_DATA);
            expectMatchingResult(customerOptions, inventoryOptions, ['AAAA', 'DDDD', 'GGGG']);
        });
    });

    describe('generateMatchingActions', () => {
        let matchingLexicon;

        beforeEach(() => {
            matchingLexicon = Lexicon.normalizeLexicon(MATCHING_LEXICON_DATA);
        });

        it('generate correct matching actions if the matching group contains two options', () => {
            let customerOptions = ['AAAA', 'FFFF'];
            let inventoryOptions = ['BBBB', 'FFFF'];
            let matchingActions = Matching.generateMatchingActions(customerOptions, inventoryOptions, matchingLexicon.matching);
            expect(matchingActions.length).to.equal(2);
            expect(validateActions(matchingActions, 'set', 'AAAA')).to.equal(true);
            expect(validateActions(matchingActions, 'unset', 'AAAA')).to.equal(false);
            expect(validateActions(matchingActions, 'set', 'BBBB')).to.equal(false);
            expect(validateActions(matchingActions, 'unset', 'BBBB')).to.equal(true);
        });

        it('generate correct matching actions if the matching group contains more than two options', () => {
            let customerOptions = ['CCCC', 'FFFF'];
            let inventoryOptions = ['DDDD', 'FFFF'];
            let matchingActions = Matching.generateMatchingActions(customerOptions, inventoryOptions, matchingLexicon.matching);
            expect(matchingActions.length).to.equal(2);
            expect(validateActions(matchingActions, 'set', 'CCCC')).to.equal(true);
            expect(validateActions(matchingActions, 'unset', 'CCCC')).to.equal(false);
            expect(validateActions(matchingActions, 'unset', 'DDDD')).to.equal(true);
            expect(validateActions(matchingActions, 'set', 'DDDD')).to.equal(false);
            expect(validateActions(matchingActions, 'set', 'EEEE')).to.equal(false);
            expect(validateActions(matchingActions, 'unset', 'EEEE')).to.equal(false);

            customerOptions = ['DDDD', 'FFFF'];
            inventoryOptions = ['EEEE', 'FFFF'];
            matchingActions = Matching.generateMatchingActions(customerOptions, inventoryOptions, matchingLexicon.matching);
            expect(matchingActions.length).to.equal(2);
            expect(validateActions(matchingActions, 'set', 'DDDD')).to.equal(true);
            expect(validateActions(matchingActions, 'unset', 'DDDD')).to.equal(false);
            expect(validateActions(matchingActions, 'unset', 'EEEE')).to.equal(true);
            expect(validateActions(matchingActions, 'set', 'EEEE')).to.equal(false);
            expect(validateActions(matchingActions, 'set', 'CCCC')).to.equal(false);
            expect(validateActions(matchingActions, 'unset', 'CCCC')).to.equal(false);
        });

        it('generate correct matching actions if the we need to match more than one matching groups', () => {
            let customerOptions = ['AAAA', 'CCCC', 'FFFF'];
            let inventoryOptions = ['BBBB', 'DDDD', 'FFFF'];
            let matchingActions = Matching.generateMatchingActions(customerOptions, inventoryOptions, matchingLexicon.matching);
            expect(matchingActions.length).to.equal(4);
            expect(validateActions(matchingActions, 'set', 'AAAA')).to.equal(true);
            expect(validateActions(matchingActions, 'unset', 'AAAA')).to.equal(false);
            expect(validateActions(matchingActions, 'set', 'BBBB')).to.equal(false);
            expect(validateActions(matchingActions, 'unset', 'BBBB')).to.equal(true);
            expect(validateActions(matchingActions, 'set', 'CCCC')).to.equal(true);
            expect(validateActions(matchingActions, 'unset', 'CCCC')).to.equal(false);
            expect(validateActions(matchingActions, 'unset', 'DDDD')).to.equal(true);
            expect(validateActions(matchingActions, 'set', 'DDDD')).to.equal(false);
            expect(validateActions(matchingActions, 'set', 'EEEE')).to.equal(false);
            expect(validateActions(matchingActions, 'unset', 'EEEE')).to.equal(false);
        });

        it('shoudln\'t generate matching actions if the customer options are the same as inventory options', () => {
            let customerOptions = ['AAAA', 'FFFF'];
            let inventoryOptions = ['AAAA', 'GGGG'];
            let matchingActions = Matching.generateMatchingActions(customerOptions, inventoryOptions, matchingLexicon.matching);
            expect(matchingActions.length).to.equal(0);

            customerOptions = ['AAAA', 'CCCC', 'FFFF'];
            inventoryOptions = ['AAAA', 'CCCC', 'GGGG'];
            matchingActions = Matching.generateMatchingActions(customerOptions, inventoryOptions, matchingLexicon.matching);
            expect(matchingActions.length).to.equal(0);
        });
    });
});

function validateActions(actions, action, target) {
    let filteredActions = actions.filter(actionItem => {
        return actionItem.action === action && actionItem.target === target;
    });
    return !!filteredActions.length;
}

function expectMatchingResult(customerOptions, inventoryOptions, expectedInventoryOptions) {
    let matchedInventoryOptions = Matching.matching(customerOptions, inventoryOptions, MATCHING_LEXICON_DATA);
    expect(matchedInventoryOptions.sort().join(',')).to.equal(expectedInventoryOptions.sort().join(','));
}