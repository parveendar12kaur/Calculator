const path = require('path');
const chai = require('chai');
const Axios = require('axios');
const AxiosMockAdapter = require('axios-mock-adapter');

const ENV = require(path.resolve(__dirname, '../../dist/env'));
const utils = require(path.resolve(__dirname, '../utils'));
const Agent = require(path.resolve(__dirname, '../../dist'));
const Validator = require(path.resolve(__dirname, '../../dist/validator/'));
const MARKETING_LEXICON_DATA = require(path.resolve(__dirname, '../fixtures/marketingLexicon.json'));
const expect = chai.expect;

describe('Validator', () => {

    describe('validate method ', () => {

        describe('when lexicon service is up', () => {
            let mock;

            beforeEach(() => {
                mock = new AxiosMockAdapter(Axios);
                mock.onGet(ENV.MARKETING_LEXICON).reply(200, Agent.Lexicon.normalizeLexicon(MARKETING_LEXICON_DATA));
            });

            it('should return validate result as true if the configuration is correct', (done) => {
                Agent.validate(utils.generateConfigurationByOptionList(['$AAAA','$DDDD','$GGGG','$IIII']), function(response) {
                    expect(response.success).to.equal(true);
                    done();
                });
            });

            it('should return validate result as true if the configurations is correct', (done) => {
                Agent.validatePromise([
                        utils.generateConfigurationByOptionList(['$AAAA','$DDDD','$GGGG','$IIII']),
                        utils.generateConfigurationByOptionList(['$AAAA','$DDDD','$GGGG','$IIII'])
                    ])
                    .then(response => {
                        expect(response[0].success).to.equal(true);
                        expect(response[1].success).to.equal(true);
                        done();
                    });
            });

            it('should return validate result as array if the configurations are array', (done) => {
                let configuration = utils.generateConfigurationByOptionList(['$AAAA','$DDDD','$GGGG','$IIII']);
                let configurations = [configuration, configuration, configuration];
                Agent.validate(configurations, function(response) {
                    expect(Array.isArray(response)).to.equal(true);
                    expect(response[0].success).to.equal(true);
                    expect(response[1].success).to.equal(true);
                    expect(response[2].success).to.equal(true);
                    done();
                });
            });

            afterEach(() => {
                mock.restore();
            });
        });
    });

    describe('validatePromise method ', () => {

        describe('when lexicon service is up', () => {
            let mock;

            beforeEach(() => {
                mock = new AxiosMockAdapter(Axios);
                mock.onGet(ENV.MARKETING_LEXICON).reply(200, MARKETING_LEXICON_DATA);
            });

            it('should return validate result as true if the configuration is correct', (done) => {
                Agent.validatePromise(utils.generateConfigurationByOptionList(['$AAAA','$DDDD','$GGGG','$IIII']))
                    .then( response => {
                        expect(response.success).to.equal(true);
                        done();
                    });
            });

            afterEach(() => {
                mock.restore();
            });
        });

        describe('when lexicon service is down [no service stub]', () => {
            let mock;

            beforeEach(() => {
                mock = new AxiosMockAdapter(Axios);
                mock.onGet(ENV.MARKETING_LEXICON).reply(500);
            });

            afterEach(() => {
                mock.restore();
            });

            it('should catch the exception', (done) => {
                Agent.validatePromise(utils.generateConfigurationByOptionList(['$AAAA','$DDDD','$GGGG','$HHHH']))
                    .then( response => {
                        expect(response.success).to.equal(false);
                        done();
                    });
            });
        });
    });

    describe('validateRules method ', () => {
        it('should return validate result as true if the configuration is correct', () => {
            expect(Agent.validateRules(['$AAAA','$DDDD','$GGGG','$JJJJ'], Agent.Lexicon.normalizeLexicon(MARKETING_LEXICON_DATA)).success).to.equal(true);
        });

        it('should return validate result as false if the configuration is invalid', () => {
            expect(Agent.validateRules(['$AAAA','$DDDD','$GGGG'], MARKETING_LEXICON_DATA).success).to.equal(false);
            expect(Agent.validateRules(['$AAAA','$DDDD','$HHHH'], MARKETING_LEXICON_DATA).success).to.equal(false);
            expect(Agent.validateRules(['$DDDD','$HHHH'], MARKETING_LEXICON_DATA).success).to.equal(false);
            expect(Agent.validateRules(['$DDDD_NOT_IN_LEXICON','$HHHH'], MARKETING_LEXICON_DATA).success).to.equal(false);
        });
    });

    describe('validateDuplication method ', () => {
        it('should return success if no duplication', () => {
            let groupOfOptions = ['$GROUP1', '$GROUP2', '$GROUP3', '$GROUP4', '$GROUP5', '$GROUP6'];
            expect(Validator.validateDuplication(groupOfOptions, MARKETING_LEXICON_DATA).success).to.equal(true);

            groupOfOptions = ['$GROUP1', '$GROUP2'];
            expect(Validator.validateDuplication(groupOfOptions, MARKETING_LEXICON_DATA).success).to.equal(true);
        });

        it('should return false if we have duplication', () => {
            let groupOfOptions = ['$GROUP1', '$GROUP2', '$GROUP3', '$GROUP4', '$GROUP5', '$GROUP6', '$GROUP5']
            expect(Validator.validateDuplication(groupOfOptions, MARKETING_LEXICON_DATA).success).to.equal(false);

            groupOfOptions = ['$GROUP1', '$GROUP1'];
            expect(Validator.validateDuplication(groupOfOptions, MARKETING_LEXICON_DATA).success).to.equal(false);
        });
    });

    describe('validateArbitraryOptions method ', () => {
        it('should return success if there\'s no arbitrary option codes', () => {
            let options = ['$AAAA'];
            expect(Validator.validateArbitraryOptions(options, MARKETING_LEXICON_DATA).success).to.equal(true);
        });

        it('should return false if there\'re some arbitrary option codes', () => {
            let options = ['$ABCD'];
            expect(Validator.validateArbitraryOptions(options, MARKETING_LEXICON_DATA).success).to.equal(false);
        });
    });

    describe('validatePrice method ', () => {
        it('should return true if price is correct', () => {
            let options = [
                {
                    'code': '$AAAA',
                    'price': 0
                }
            ];
            expect(Validator.validatePrice(options, MARKETING_LEXICON_DATA).success).to.equal(true);
        });

        it('should return false even if the price is customized', () => {
            let options = [
                {
                    'code': '$AAAA',
                    'price': 10,
                    'isCustomPricing': true
                }
            ];
            expect(Validator.validatePrice(options, MARKETING_LEXICON_DATA).success).to.equal(false);
        });

        it('should return false if price is incorrect', () => {
            let options = [
                {
                    'code': '$AAAA',
                    'price': 10
                }
            ];
            expect(Validator.validatePrice(options, MARKETING_LEXICON_DATA).success).to.equal(false);
        });

        it('should return true if we are passing the isCustomPricing flag as true with valid validation type', () => {
            let options = [
                {
                    'code': '$AAAA',
                    'price': 10,
                    'isCustomPricing': true
                }
            ];
            expect(Validator.validatePrice(options, MARKETING_LEXICON_DATA, Agent.TYPES.VALIDATION_TYPE_MARKETING_WITH_CUSTOM_PRICING).success).to.equal(true);
            expect(Validator.validatePrice(options, MARKETING_LEXICON_DATA, Agent.TYPES.VALIDATION_TYPE_MARKETING_BY_VMID_WITH_CUSTOM_PRICING).success).to.equal(true);
            expect(Validator.validatePrice(options, MARKETING_LEXICON_DATA, Agent.TYPES.VALIDATION_TYPE_MARKETING).success).to.equal(false);
            expect(Validator.validatePrice(options, MARKETING_LEXICON_DATA, Agent.TYPES.VALIDATION_TYPE_MARKETING_BY_VMID).success).to.equal(false);
        });

        it('should return false even if we are passing the valid validation flag but isCustomPricing is false with incorrect pricing', () => {
            let options = [
                {
                    'code': '$AAAA',
                    'price': 10,
                    'isCustomPricing': false
                }
            ];
            expect(Validator.validatePrice(options, MARKETING_LEXICON_DATA, Agent.TYPES.VALIDATION_TYPE_MARKETING_WITH_CUSTOM_PRICING).success).to.equal(false);
            expect(Validator.validatePrice(options, MARKETING_LEXICON_DATA, Agent.TYPES.VALIDATION_TYPE_MARKETING_BY_VMID_WITH_CUSTOM_PRICING).success).to.equal(false);
            expect(Validator.validatePrice(options, MARKETING_LEXICON_DATA, Agent.TYPES.VALIDATION_TYPE_MARKETING).success).to.equal(false);
            expect(Validator.validatePrice(options, MARKETING_LEXICON_DATA, Agent.TYPES.VALIDATION_TYPE_MARKETING_BY_VMID).success).to.equal(false);
        });
    });

    describe('validatePriceWithSubtotal method ', () => {
        it('should return true if price is correct', () => {
            let configuration = {
                'subtotal': 0,
                'options': [
                    {
                        'code': '$AAAA',
                        'price': 0
                    }
                ]
            };
            expect(Validator.validatePriceWithSubtotal(configuration, MARKETING_LEXICON_DATA).success).to.equal(true);
        });

        it('should return false even if the price is customized', () => {
            let configuration = {
                'subtotal': 10,
                'options': [
                    {
                        'code': '$AAAA',
                        'price': 10,
                        'isCustomPricing': true
                    }
                ]
            };
            expect(Validator.validatePriceWithSubtotal(configuration, MARKETING_LEXICON_DATA).success).to.equal(false);
        });

        it('should return false if price is incorrect', () => {
            let configuration = {
                'subtotal': 10,
                'options': [
                    {
                        'code': '$AAAA',
                        'price': 0
                    }
                ]
            };
            expect(Validator.validatePriceWithSubtotal(configuration, MARKETING_LEXICON_DATA).success).to.equal(false);
        });

        it('should return true when subtotal is correct', () => {
            let dummyLexion = {
                'options': {
                    '$AAAA': {
                        'price': 100
                    },
                    '$BBBB': {
                        'price': 1000
                    },
                    '$CCCC': {
                        'price': 5000
                    }
                }
            };
            let configuration = {
                'subtotal': 100,
                'options': [
                    {
                        'code': '$AAAA',
                        'price': 100
                    }
                ]
            };
            expect(Validator.validatePriceWithSubtotal(configuration, dummyLexion).success).to.equal(true);
            configuration = {
                'subtotal': 10,
                'options': [
                    {
                        'code': '$AAAA',
                        'price': 100
                    }
                ]
            };
            expect(Validator.validatePriceWithSubtotal(configuration, dummyLexion).success).to.equal(false);
            configuration = {
                'subtotal': 1100,
                'options': [
                    {
                        'code': '$AAAA',
                        'price': 100
                    },
                    {
                        'code': '$BBBB',
                        'price': 1000
                    }
                ]
            };
            expect(Validator.validatePriceWithSubtotal(configuration, dummyLexion).success).to.equal(true);            
            configuration = {
                'subtotal': 100,
                'options': [
                    {
                        'code': '$AAAA',
                        'price': 100
                    },
                    {
                        'code': '$BBBB',
                        'price': 1000
                    }
                ]
            };
            expect(Validator.validatePriceWithSubtotal(configuration, dummyLexion).success).to.equal(false);
            configuration = {
                'subtotal': 6000,
                'options': [
                    {
                        'code': '$CCCC',
                        'price': 5000
                    },
                    {
                        'code': '$BBBB',
                        'price': 1000
                    }
                ]
            };
            expect(Validator.validatePriceWithSubtotal(configuration, dummyLexion).success).to.equal(true);            
            configuration = {
                'subtotal': 1090,
                'options': [
                    {
                        'code': '$AAAA',
                        'price': 90
                    },
                    {
                        'code': '$BBBB',
                        'price': 1000
                    }
                ]
            };
            expect(Validator.validatePriceWithSubtotal(configuration, dummyLexion).success).to.equal(false);
        });        
    });

    describe('getOptionPrice method ', () => {
        it('should return price value from price attribute if we don\'t have pricing attribute defined', () => {
            let dummyLexion = {
                'options': {
                    '$AAAA': {
                        'price': 100
                    }
                }
            };
            expect(Validator.getOptionPrice('$AAAA', dummyLexion)).to.equal(100);
        });

        it('should return price value from pricing attribute if we have it defined', () => {
            let dummyLexion = {
                'options': {
                    '$AAAA': {
                        'pricing': [
                            {
                                'type': 'base',
                                'value': 1000,
                                'context': 'default'
                            },
                            {
                                'type': 'upgrade',
                                'value': 3000,
                                'context': 'default'
                            }
                        ],
                        'price': 2000
                    }
                }
            };
            expect(Validator.getOptionPrice('$AAAA', dummyLexion)).to.equal(1000);
            expect(Validator.getOptionPrice('$AAAA', dummyLexion, 'default', 'upgrade')).to.equal(3000);
        });
    });

    describe('validateRequired method ', () => {
        it('should return success if no required group is missed', () => {
            let groupOfOptions = ['$GROUP1', '$GROUP2', '$GROUP3', '$GROUP4', '$GROUP5', '$GROUP6'];
            expect(Validator.validateRequired(groupOfOptions, MARKETING_LEXICON_DATA).success).to.equal(true);
        });

        it('should return false if we are missing some group codes', () => {
            let groupOfOptions = ['$GROUP2', '$GROUP3', '$GROUP4', '$GROUP5', '$GROUP6'];
            expect(Validator.validateRequired(groupOfOptions, MARKETING_LEXICON_DATA).success).to.equal(false);

            groupOfOptions = ['$GROUP2', '$GROUP6'];
            expect(Validator.validateRequired(groupOfOptions, MARKETING_LEXICON_DATA).success).to.equal(false);
        });
    });

    describe('validateOptionSetRules method ', () => {
        it('should return success if the sourceOptions are following the rules we defined in lexicon', () => {
            let sourceOptions = ['$AAAA','$DDDD','$GGGG','$JJJJ'];
            expect(Validator.validateOptionSetRules(sourceOptions, MARKETING_LEXICON_DATA).success).to.equal(true);

            sourceOptions = ['$AAAA','$DDDD','$GGGG','$IIII'];
            expect(Validator.validateOptionSetRules(sourceOptions, MARKETING_LEXICON_DATA).success).to.equal(true);
        });

        it('should return false if the sourceOptions are following the rules we defined in lexicon', () => {
            let sourceOptions = ['$AAAA','$DDDD','$GGGG','$HHHH'];
            expect(Validator.validateOptionSetRules(sourceOptions, MARKETING_LEXICON_DATA).success).to.equal(false);

            sourceOptions = ['$AAAA','$BBBB','$GGGG','$HHHH'];
            expect(Validator.validateOptionSetRules(sourceOptions, MARKETING_LEXICON_DATA).success).to.equal(false);
        });
    });

    describe('toggleOption method ', () => {
        it('should cover edge cases to set/unset option', () => {
            let dummyLexion = {
                options: {
                    AAAA: {
                        code: 'AAAA'
                    },
                    BBBB: {
                        code: 'BBBB',
                        unset_rules: [
                            {
                                action: 'set',
                                target: 'DDDD'
                            }
                        ]
                    },
                    CCCC: {
                        code: 'CCCC',
                        set_rules: [
                            {
                                action: 'set',
                                target: 'BBBB'
                            },
                            {
                                action: 'unset',
                                target: 'AAAA'
                            }
                        ],
                        unset_rules: [
                            {
                                action: 'set',
                                target: 'AAAA'
                            },
                            {
                                action: 'unset',
                                target: 'BBBB'
                            }
                        ]
                    },
                    DDDD: {
                        code: 'DDDD'
                    }
                }
            };
            expectToggleOptionResult(['BBBB'], 'CCCC', Agent.TYPES.UNSET_RULE_ACTION, ['BBBB'], dummyLexion);
            expectToggleOptionResult(['BBBB'], 'HAHAHAHA', Agent.TYPES.SET_RULE_ACTION, ['BBBB'], dummyLexion);
            expectToggleOptionResult(['AAAA', 'CCCC'], 'CCCC', Agent.TYPES.UNSET_RULE_ACTION, ['AAAA'], dummyLexion);
            expectToggleOptionResult(['AAAA'], 'CCCC', Agent.TYPES.SET_RULE_ACTION, ['BBBB', 'CCCC'], dummyLexion);
        });

        it('should cover edge cases to set/unset option with operator and', () => {
            let dummyLexion = {
                options: {
                    AAAA: {
                        code: 'AAAA'
                    },
                    BBBB: {
                        code: 'BBBB'
                    },
                    CCCC: {
                        code: 'CCCC',
                        set_rules: [
                            {
                                action: 'set',
                                target: 'DDDD',
                                operator: 'and',
                                condition_code: 'AAAA',
                                condition_state: 'set'
                            },
                            {
                                operator: 'and',
                                condition_code: 'BBBB',
                                condition_state: 'set'
                            },
                            {
                                operator: 'and',
                                condition_code: 'EEEE',
                                condition_state: 'set'
                            },
                            {
                                condition_code: 'FFFF',
                                condition_state: 'unset'
                            }
                        ]
                    },
                    DDDD: {
                        code: 'DDDD'
                    },
                    EEEE: {
                        code: 'EEEE'
                    }
                }
            };
            dummyLexion = Agent.Lexicon.normalizeLexicon(dummyLexion);
            expectToggleOptionResult(['AAAA'], 'BBBB', Agent.TYPES.SET_RULE_ACTION, ['AAAA', 'BBBB'], dummyLexion);
            expectToggleOptionResult(['BBBB'], 'CCCC', Agent.TYPES.SET_RULE_ACTION, ['BBBB', 'CCCC'], dummyLexion);
            expectToggleOptionResult(['EEEE'], 'CCCC', Agent.TYPES.SET_RULE_ACTION, ['EEEE', 'CCCC'], dummyLexion);
            expectToggleOptionResult(['AAAA', 'BBBB', 'EEEE'], 'CCCC', Agent.TYPES.SET_RULE_ACTION, ['AAAA', 'BBBB', 'CCCC', 'DDDD', 'EEEE'], dummyLexion);
            expectToggleOptionResult(['AAAA', 'BBBB', 'EEEE', 'FFFF'], 'CCCC', Agent.TYPES.SET_RULE_ACTION, ['AAAA', 'BBBB', 'CCCC', 'FFFF', 'EEEE'], dummyLexion);
        });

        it('should cover edge cases to set/unset option with operator or', () => {
            let dummyLexion = {
                options: {
                    AAAA: {
                        code: 'AAAA'
                    },
                    BBBB: {
                        code: 'BBBB'
                    },
                    CCCC: {
                        code: 'CCCC',
                        set_rules: [
                            {
                                action: 'set',
                                target: 'DDDD',
                                operator: 'or',
                                condition_code: 'AAAA',
                                condition_state: 'set'
                            },
                            {
                                operator: 'or',
                                condition_code: 'BBBB',
                                condition_state: 'set'
                            },
                            {
                                operator: 'or',
                                condition_code: 'EEEE',
                                condition_state: 'set'
                            },
                            {
                                condition_code: 'FFFF',
                                condition_state: 'unset'
                            }
                        ]
                    },
                    DDDD: {
                        code: 'DDDD'
                    },
                    EEEE: {
                        code: 'EEEE'
                    }
                }
            };
            dummyLexion = Agent.Lexicon.normalizeLexicon(dummyLexion);
            expectToggleOptionResult(['AAAA'], 'BBBB', Agent.TYPES.SET_RULE_ACTION, ['AAAA', 'BBBB'], dummyLexion);
            expectToggleOptionResult(['AAAA'], 'CCCC', Agent.TYPES.SET_RULE_ACTION, ['DDDD', 'AAAA', 'CCCC'], dummyLexion);
            expectToggleOptionResult(['BBBB', 'FFFF'], 'CCCC', Agent.TYPES.SET_RULE_ACTION, ['BBBB', 'CCCC', 'DDDD', 'FFFF'], dummyLexion);
            expectToggleOptionResult(['AAAA', 'FFFF'], 'CCCC', Agent.TYPES.SET_RULE_ACTION, ['CCCC', 'DDDD', 'AAAA', 'FFFF'], dummyLexion);
            expectToggleOptionResult(['BBBB', 'FFFF'], 'CCCC', Agent.TYPES.SET_RULE_ACTION, ['CCCC', 'DDDD', 'BBBB', 'FFFF'], dummyLexion);
            expectToggleOptionResult(['EEEE', 'FFFF'], 'CCCC', Agent.TYPES.SET_RULE_ACTION, ['CCCC', 'DDDD', 'EEEE', 'FFFF'], dummyLexion);
        });

        it('should cover edge cases to set/unset option with pure conditonal settings', () => {
            let dummyLexion = {
                options: {
                    AAAA: {
                        code: 'AAAA'
                    },
                    BBBB: {
                        code: 'BBBB',
                        set_rules: [
                            {
                                action: 'set',
                                target: 'BBBB'
                            },
                            {
                                action: 'set',
                                target: 'DDDD'
                            }
                        ],
                        unset_rules: [
                            {
                                action: 'unset',
                                target: 'BBBB'
                            }
                        ]
                    },
                    CCCC: {
                        code: 'CCCC',
                        set_rules: [
                            {
                                action: 'set',
                                target: 'CCCC'
                            },
                            {
                                action: 'unset',
                                target: 'DDDD'
                            },
                            {
                                action: 'unset',
                                target: 'CCCC',
                                condition_code: 'BBBB',
                                condition_state: 'set'
                            }
                        ],
                        unset_rules: [
                            {
                                action: 'unset',
                                target: 'CCCC'
                            },
                            {
                                action: 'set',
                                target: 'DDDD'
                            }
                        ]
                    },
                    DDDD: {
                        code: 'DDDD',
                        set_rules: [
                            {
                                action: 'set',
                                target: 'DDDD'
                            },
                            {
                                action: 'unset',
                                target: 'CCCC'
                            }
                        ],
                        unset_rules: [
                            {
                                action: 'unset',
                                target: 'DDDD'
                            },
                            {
                                action: 'set',
                                target: 'CCCC'
                            }
                        ]
                    },
                    EEEE: {
                        code: 'EEEE',
                        set_rules: [
                            {
                                action: 'set',
                                target: 'EEEE'
                            },
                            {
                                action: 'set',
                                target: 'GGGG',
                                condition_code: 'FFFF',
                                condition_state: 'unset'
                            }
                        ],
                        unset_rules: [
                            {
                                action: 'unset',
                                target: 'EEEE'
                            }
                        ]
                    },
                    FFFF: {
                        code: 'FFFF'
                    },
                    GGGG: {
                        code: 'GGGG'
                    }
                }
            };
            dummyLexion = Agent.Lexicon.normalizeLexicon(dummyLexion);
            expectToggleOptionResult(['AAAA'], 'BBBB', Agent.TYPES.SET_RULE_ACTION, ['AAAA', 'BBBB', 'DDDD'], dummyLexion);
            expectToggleOptionResult(['AAAA', 'DDDD'], 'CCCC', Agent.TYPES.SET_RULE_ACTION, ['AAAA', 'CCCC'], dummyLexion);
            expectToggleOptionResult(['AAAA', 'CCCC'], 'BBBB', Agent.TYPES.SET_RULE_ACTION, ['AAAA', 'BBBB', 'DDDD'], dummyLexion);
            expectToggleOptionResult(['AAAA', 'BBBB', 'DDDD'], 'CCCC', Agent.TYPES.SET_RULE_ACTION, ['AAAA', 'BBBB', 'DDDD'], dummyLexion);
            expectToggleOptionResult(['AAAA'], 'EEEE', Agent.TYPES.SET_RULE_ACTION, ['AAAA', 'EEEE', 'GGGG'], dummyLexion);
            expectToggleOptionResult(['AAAA', 'FFFF'], 'EEEE', Agent.TYPES.SET_RULE_ACTION, ['AAAA', 'FFFF', 'EEEE'], dummyLexion);
        });
    });

    describe('getSubTotal method ', () => {
        it('should cover edge cases to set/unset option', () => {
            let dummyLexion = {
                options: {
                    AAAA: {
                        code: 'AAAA',
                        price: 1000
                    },
                    BBBB: {
                        code: 'BBBB',
                        price: 2000
                    },
                    CCCC: {
                        code: 'CCCC',
                        price: 3000
                    },
                    DDDD: {
                        code: 'DDDD',
                        price: 4000
                    }
                }
            };
            expect(Agent.getSubTotal(['AAAA'], dummyLexion)).to.equal(1000);
            expect(Agent.getSubTotal(['AAAA', 'DDDD'], dummyLexion)).to.equal(5000);
        });
    });

    describe('toggleOptionByGroup method ', () => {
        it('should do setOption when we try to toggle exclusive and required option', () => {
            let dummyLexion = {
                groups: [
                    {
                        code: 'GROUP1',
                        context: 'default',
                        required: true,
                        exclusive: true,
                        options: [
                            'AAAA',
                            'BBBB'
                        ]
                    }
                ],
                options: {
                    AAAA: {
                        code: 'AAAA',
                        set_rules: [
                            {
                                target: 'AAAA',
                                action: 'set'
                            },
                            {
                                target: 'BBBB',
                                action: 'unset'
                            }
                        ],
                        unset_rules: [
                            {
                                target: 'AAAA',
                                action: 'unset'
                            },
                            {
                                target: 'BBBB',
                                action: 'set'
                            }
                        ]
                    },
                    BBBB: {
                        code: 'BBBB',
                        set_rules: [
                            {
                                target: 'BBBB',
                                action: 'set'
                            },
                            {
                                target: 'AAAA',
                                action: 'unset'
                            }
                        ],
                        unset_rules: [
                            {
                                target: 'BBBB',
                                action: 'unset'
                            },
                            {
                                target: 'AAAA',
                                action: 'set'
                            }
                        ],
                    }
                }
            };
            expect(expectToggleOptionByGroupResult(['AAAA'], 'AAAA', ['AAAA'], dummyLexion));
            expect(expectToggleOptionByGroupResult(['AAAA'], 'BBBB', ['BBBB'], dummyLexion));
            expect(expectToggleOptionByGroupResult(['BBBB'], 'AAAA', ['AAAA'], dummyLexion));
            expect(expectToggleOptionByGroupResult(['BBBB'], 'BBBB', ['BBBB'], dummyLexion));
        });

        it('should do setOption when we try to toggle required option', () => {
            let dummyLexion = {
                groups: [
                    {
                        code: 'GROUP1',
                        context: 'default',
                        required: true,
                        exclusive: false,
                        options: [
                            'AAAA',
                            'BBBB'
                        ],
                        default_options: [
                            'AAAA'
                        ]
                    }
                ],
                options: {
                    AAAA: {
                        code: 'AAAA',
                        set_rules: [
                            {
                                target: 'AAAA',
                                action: 'set'
                            }
                        ],
                        unset_rules: [
                            {
                                target: 'AAAA',
                                action: 'unset'
                            },
                            {
                                target: 'AAAA',
                                action: 'set',
                                condition_state: 'unset',
                                condition_code: 'AAAA',
                                operator: 'and'
                            },
                            {
                                condition_state: 'unset',
                                condition_code: 'BBBB'
                            }
                        ]
                    },
                    BBBB: {
                        code: 'BBBB',
                        set_rules: [
                            {
                                target: 'BBBB',
                                action: 'set'
                            }
                        ],
                        unset_rules: [
                            {
                                target: 'BBBB',
                                action: 'unset'
                            },
                            {
                                target: 'AAAA',
                                action: 'set',
                                condition_state: 'unset',
                                condition_code: 'AAAA',
                                operator: 'and'
                            },
                            {
                                condition_state: 'unset',
                                condition_code: 'BBBB'
                            }
                        ],
                    }
                }
            };
            expect(expectToggleOptionByGroupResult(['AAAA'], 'AAAA', ['AAAA'], dummyLexion));
            expect(expectToggleOptionByGroupResult(['BBBB'], 'BBBB', ['BBBB'], dummyLexion));
            expect(expectToggleOptionByGroupResult(['AAAA'], 'BBBB', ['AAAA', 'BBBB'], dummyLexion));
            expect(expectToggleOptionByGroupResult(['BBBB'], 'AAAA', ['AAAA', 'BBBB'], dummyLexion));
            expect(expectToggleOptionByGroupResult(['AAAA', 'BBBB'], 'AAAA', ['AAAA', 'BBBB'], dummyLexion));
            expect(expectToggleOptionByGroupResult(['AAAA', 'BBBB'], 'BBBB', ['AAAA', 'BBBB'], dummyLexion));
        });

        it('should do setOption or unsetOption depending on the context', () => {
            let dummyLexion = {
                groups: [
                    {
                        code: 'GROUP1',
                        context: 'default',
                        required: false,
                        exclusive: false,
                        options: [
                            'AAAA',
                            'BBBB'
                        ]
                    }
                ],
                options: {
                    AAAA: {
                        code: 'AAAA',
                        set_rules: [
                            {
                                target: 'AAAA',
                                action: 'set'
                            }
                        ],
                        unset_rules: [
                            {
                                target: 'AAAA',
                                action: 'unset'
                            }
                        ]
                    },
                    BBBB: {
                        code: 'BBBB',
                        set_rules: [
                            {
                                target: 'BBBB',
                                action: 'set'
                            }
                        ],
                        unset_rules: [
                            {
                                target: 'BBBB',
                                action: 'unset'
                            }
                        ],
                    }
                }
            };
            expect(expectToggleOptionByGroupResult(['AAAA'], 'AAAA', [], dummyLexion));
            expect(expectToggleOptionByGroupResult(['BBBB'], 'BBBB', [], dummyLexion));
            expect(expectToggleOptionByGroupResult(['AAAA'], 'BBBB', ['AAAA', 'BBBB'], dummyLexion));
            expect(expectToggleOptionByGroupResult(['BBBB'], 'AAAA', ['AAAA', 'BBBB'], dummyLexion));
            expect(expectToggleOptionByGroupResult(['AAAA', 'BBBB'], 'AAAA', ['BBBB'], dummyLexion));
            expect(expectToggleOptionByGroupResult(['AAAA', 'BBBB'], 'BBBB', ['AAAA'], dummyLexion));
        });
    });
});

function expectToggleOptionResult(options, option, action, destinationOptions, lexicon) {
    expect(JSON.stringify(Agent.toggleOption({
        options,
        option,
        lexicon,
        action
    }).sort())).to.equal(JSON.stringify(destinationOptions.sort()));
}

function expectToggleOptionByGroupResult(options, option, destinationOptions, lexicon) {
    expect(JSON.stringify(Agent.toggleOptionByGroup({
        options,
        option,
        lexicon
    }).sort())).to.equal(JSON.stringify(destinationOptions.sort()));
}
