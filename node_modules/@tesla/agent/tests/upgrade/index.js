const path = require('path');
const chai = require('chai');
const Rx = require('rxjs/rx');
const expect = chai.expect;
const difference = require('lodash/difference');

const utils = require(path.resolve(__dirname, '../utils'));
const Upgrade = require(path.resolve(__dirname, '../../dist/upgrade'))

const UPGRADE_LEXICONS = require(path.resolve(__dirname, '../fixtures/upgradeLexicon.json'));

describe('Upgrade Configuration', () => {
    describe('getEligibleUpgradableOptions method', () => {
    	it("should return correct upgradable option list based on given configuration and upgrade lexicon", () => {
            let dummyLexicon = {
                "metadata": {
                    "post_mfg_mutations": {
                        "AAAA": {
                            "type": "remote",
                            "mutation": [],
                            "requirement_relationship": "and"
                        },
                        "BBBB": {
                            "type": "remote",
                            "mutation": ["CCCC"],
                            "requirement_relationship": "and"
                        },
                        "DDDD": {
                            "type": "remote",
                            "mutation": ['EEEE', 'FFFF'],
                            "requirement_relationship": "and"
                        },
                        "GGGG": {
                            "type": "remote",
                            "mutation": ['HHHH', 'IIII'],
                            "requirement_relationship": "or"
                        }
                    }
                }
            };
    	    expect(Upgrade.getEligibleUpgradableOptions(['AAAA'], dummyLexicon).length).to.equal(0);
            expect(Upgrade.getEligibleUpgradableOptions(['BBBB'], dummyLexicon).length).to.equal(1);
            expect(difference(Upgrade.getEligibleUpgradableOptions(['BBBB'], dummyLexicon), ['AAAA']).length).to.equal(0);
            expect(Upgrade.getEligibleUpgradableOptions(['CCCC'], dummyLexicon).length).to.equal(2);
            expect(difference(Upgrade.getEligibleUpgradableOptions(['CCCC'], dummyLexicon), ['AAAA', 'BBBB']).length).to.equal(0);
            expect(Upgrade.getEligibleUpgradableOptions(['AAAA', 'BBBB'], dummyLexicon).length).to.equal(0);
            expect(Upgrade.getEligibleUpgradableOptions(['AAAA', 'CCCC'], dummyLexicon).length).to.equal(1);
            expect(difference(Upgrade.getEligibleUpgradableOptions(['AAAA', 'CCCC'], dummyLexicon), ['BBBB']).length).to.equal(0);
            expect(Upgrade.getEligibleUpgradableOptions(['EEEE'], dummyLexicon).length).to.equal(1);
            expect(difference(Upgrade.getEligibleUpgradableOptions(['EEEE'], dummyLexicon), ['AAAA']).length).to.equal(0);
            expect(Upgrade.getEligibleUpgradableOptions(['FFFF'], dummyLexicon).length).to.equal(1);
            expect(difference(Upgrade.getEligibleUpgradableOptions(['FFFF'], dummyLexicon), ['AAAA']).length).to.equal(0);
            expect(Upgrade.getEligibleUpgradableOptions(['EEEE', 'FFFF'], dummyLexicon).length).to.equal(2);
            expect(difference(Upgrade.getEligibleUpgradableOptions(['EEEE', 'FFFF'], dummyLexicon), ['AAAA', 'DDDD']).length).to.equal(0);
            expect(Upgrade.getEligibleUpgradableOptions(['HHHH'], dummyLexicon).length).to.equal(2);
            expect(difference(Upgrade.getEligibleUpgradableOptions(['HHHH'], dummyLexicon), ['AAAA', 'GGGG']).length).to.equal(0);
            expect(Upgrade.getEligibleUpgradableOptions(['IIII'], dummyLexicon).length).to.equal(2);
            expect(difference(Upgrade.getEligibleUpgradableOptions(['IIII'], dummyLexicon), ['AAAA', 'GGGG']).length).to.equal(0);
            expect(Upgrade.getEligibleUpgradableOptions(['HHHH', 'IIII'], dummyLexicon).length).to.equal(2);
            expect(difference(Upgrade.getEligibleUpgradableOptions(['HHHH', 'IIII'], dummyLexicon), ['AAAA', 'GGGG']).length).to.equal(0);
            expect(Upgrade.getEligibleUpgradableOptions(['CCCC', 'EEEE', 'FFFF', 'HHHH'], dummyLexicon).length).to.equal(4);
            expect(difference(Upgrade.getEligibleUpgradableOptions(['CCCC', 'EEEE', 'FFFF', 'HHHH'], dummyLexicon), ['AAAA', 'BBBB', 'DDDD', 'GGGG']).length).to.equal(0);
    	});
    });

    describe('upgrade method', () => {
        it("should return potential upgraded configuration list by given configuration and upgrade lexicon", () => {
            let invalidUpgrade = Upgrade.upgrade([], UPGRADE_LEXICONS);
            expect(invalidUpgrade.success).to.equal(false);
            let validUpgrade = Upgrade.upgrade(['ZZZZ'], UPGRADE_LEXICONS);
            expect(validUpgrade.success).to.equal(true);
            expect(validUpgrade.data.length).to.equal(3);
            let upgradedOptions = validUpgrade.data.map(configuration => configuration.upgradedOptions.sort().join(','));
            expect(upgradedOptions.indexOf(['ZZZZ', 'AAAA'].sort().join(',')) > -1).to.equal(true);
            expect(upgradedOptions.indexOf(['ZZZZ', 'AAAA', 'BBBB'].sort().join(',')) > -1).to.equal(true);
        });
    });
});
