const path = require('path');
const chai = require('chai');
const expect = chai.expect;
const Axios = require('axios');
const AxiosMockAdapter = require('axios-mock-adapter');

const utils = require(path.resolve(__dirname, '../utils'));
const Lexicon = require(path.resolve(__dirname, '../../dist/utils/lexicon'));
const TYPES = require(path.resolve(__dirname, '../../dist/utils/types'));
const ENV = require(path.resolve(__dirname, '../../dist/env'));
const MARKETING_LEXICON_DATA = require(path.resolve(__dirname, '../fixtures/marketingLexicon.json'));

describe('Lexicon', () => {
    describe('normalizeLexicon method ', () => {
        it('should inject group to options', () => {
            let dummyLexion = {
                groups: [
                    {
                        code: 'AAAA',
                        context: 'default',
                        groups: [],
                        options: [
                            'BBBB',
                            'CCCC',
                            'EEEE'
                        ]
                    },
                    {
                        code: 'BBBB',
                        context: 'damn_context',
                        groups: [],
                        options: [
                            'BBBB',
                            'CCCC',
                            'EEEE'
                        ]
                    }
                ],
                options: {
                    BBBB: {
                        code: 'BBBB'
                    },
                    CCCC: {
                        code: 'CCCC'
                    },
                    DDDD: {
                        code: 'DDDD'
                    }
                }
            };
            let dummyLexiconWithGroupInOptions = Lexicon.normalizeLexicon(dummyLexion);
            expect(dummyLexiconWithGroupInOptions.options.BBBB.group).to.equal('AAAA');
            expect(dummyLexiconWithGroupInOptions.options.CCCC.group).to.equal('AAAA');
            expect(dummyLexiconWithGroupInOptions.options.DDDD.group).to.equal(undefined);
            expect(dummyLexiconWithGroupInOptions.matching.length).to.equal(0);
        });

        it('should extract matching groups', () => {
            let dummyLexion = {
                groups: [
                    {
                        code: 'MATCHING_GROUP1',
                        context: 'match',
                        groups: [],
                        options: [
                            'BBBB',
                            'CCCC',
                            'EEEE'
                        ]
                    },
                    {
                        code: 'DANM_CONTEXT1',
                        context: 'damn_context',
                        groups: [],
                        options: [
                            'BBBB',
                            'CCCC',
                            'EEEE'
                        ]
                    }
                ],
                options: {
                    BBBB: {
                        code: 'BBBB'
                    },
                    CCCC: {
                        code: 'CCCC'
                    },
                    DDDD: {
                        code: 'DDDD'
                    }
                }
            };
            let dummyLexiconWithGroupInOptions = Lexicon.normalizeLexicon(dummyLexion);
            expect(dummyLexiconWithGroupInOptions.matching.length).to.equal(1);
            expect(dummyLexiconWithGroupInOptions.matching[0].code).to.equal('MATCHING_GROUP1');
        });
    });
    
    describe('getLexicon$ method ', () => {
        let mock;

        beforeEach(() => {
            mock = new AxiosMockAdapter(Axios);
            mock.onGet(ENV.MARKETING_LEXICON).reply(500);
        });

        it('should catch the http exception [no service stub]', (done) => {
            Lexicon.getLexicon$(utils.generateConfigurationByOptionList(['$BT35','$APPA','$CP30','$DV4W','$IN3TB','$PMLS','$PRM30','$RF3C','$TW01','$W32S']), TYPES.VALIDATION_TYPE_MARKETING)
              .subscribe(
                    response => {
                        expect(response).to.equal(TYPES.EXCEPTION_HTTP_REQUEST);
                        done();
                    },
                    error => {
                        done();  
                    }
                );
        });

        afterEach(() => {
            mock.restore();
        });
    });

    describe('getOptionRules method ', () => {
        it('should return empty if option is not in lexicon', () => {
            let rules = Lexicon.getOptionRules({
                lexicon: MARKETING_LEXICON_DATA,
                option: '$AAAA'
            });
            expect(Array.isArray(rules)).to.equal(true);
            expect(rules.length).to.equal(0);
        });

        it('should return empty if option doesn\'t have computed rules', () => {
            let dummyLexion = {
                options: {
                    BBBB: {
                        code: 'BBBB'
                    },
                    CCCC: {
                        code: 'CCCC',
                        computed_rules: {
                            set_rules: [
                                {
                                    action: 'set',
                                    target: 'EEEE'
                                }
                            ]
                        }
                    }
                }
            };
            let rules = Lexicon.getOptionRules({
                lexicon: dummyLexion,
                option: 'BBBB'
            });
            expect(Array.isArray(rules)).to.equal(true);
            expect(rules.length).to.equal(0);

            rules = Lexicon.getOptionRules({
                lexicon: dummyLexion,
                option: 'CCCC',
                type: 'unset'
            });
            expect(Array.isArray(rules)).to.equal(true);
            expect(rules.length).to.equal(0);
        });
    });

    describe('normalizeRule method ', () => {
        it('should return nomalized rule', () => {
            let dummyRules = [
                {
                    action: "set",
                    target: "AAAA",
                    operator: "and",
                    condition_code: "AAAA",
                    condition_state: "unset"
                },
                {
                    operator: "and",
                    condition_code: "BBBB",
                    condition_state: "unset"
                },
                {
                    condition_code: "CCCC",
                    condition_state: "unset"
                }
            ];
            let normalizedRules = Lexicon.normalizeRule(dummyRules);
            expect(JSON.stringify(normalizedRules)).to.equal(JSON.stringify([{"operatorConditions":[{"conditionCode":"AAAA","conditionState":"unset"},{"conditionCode":"BBBB","conditionState":"unset"},{"conditionCode":"CCCC","conditionState":"unset"}],"action":"set","target":"AAAA","operator":"and"}]));
        });
    });    
});