/* global window */

'use strict';

/**
 * tesla-lang
 *
 * Internationalization capabilities for Tesla web applications
 *
 * Contains the following modules:
 *
 *  NumberFormat  - i81n formatting for numbers and currency
 *  UnitConverter - Basic unit conversions
 *  LocaleStore   - Provides easy to use internationalization capabilities for your webapp, including
 *                  key/value lookup, variable replacement, and number & currency formatting.
 *
 *
 *  Also includes other methods for determining markets, supported locales
 */

// import only what we need from lodash
var _assign = require('lodash/assign');
var _clone = require('lodash/clone');
var _filter = require('lodash/filter');
var _get = require('lodash/get');
var _has = require('lodash/has');
var _keys = require('lodash/keys');
var _map = require('lodash/map');
var _pick = require('lodash/pick');
var _trim = require('lodash/trim');
var _isObject = require('lodash/isObject');
var _times = require('lodash/times')

// lodash methods used:  clone, filter, map, pick, keys, assign, get, set, trim

var moment = require('moment');
var Location = require('@web/tesla-rest-location/api/location');
var Utils = require('./lib/Utils');

var momentConfig = require('./lib/momentConfig');
var NumberFormat = require('./lib/NumberFormat');

// Tesla regions & markets
var list = require('./data/common/list.json');
var intervalPriceFormat = require('./data/interval_price_format.json');
var superRegions = require('./data/super_regions.json').regions;
var teslaMarkets = require('./data/tesla_markets.json');
var currencyCodeMap = require('./data/currency_code_map.json');
var languageMap = require('./data/language_map.json');

// default locale
var __selectedLanguage = 'en';
var __defaultLocale = 'en_US';
var __selectedLocale = __defaultLocale;

// set strings here during application initialization to leverage __getStrings method
var __localeStrings = {};

// ISO
var DEFAULT_DATE_FORMAT = 'YYYY-MM-DD';

/**
 * Set locale for number/data formatting
 * Set whenever the locale changes
 * @param {String} locale
 */
function setLocale(locale) {

    // ensure locale is in the proper case
    var parsedLocale = Utils.parseLocale(locale);

    if(parsedLocale){
        locale = parsedLocale.locale;
    }

    if (isSupportedLocale(locale)) {

        var cfg = momentConfig.getLocaleSettings(locale);

        if (cfg) {
            moment.locale(locale, cfg);
        }

        NumberFormat.setLocale(locale);

        __selectedLanguage = parsedLocale.lang;
        __selectedLocale = locale;
    }
    else {
        throw new Error('setLocale ' + locale + ' not a supported locale! ');
    }
}

/**
 * Returns true/false if locale code is one that Tesla supports
 * @return {Boolean} [description]
 */
function isSupportedLocale(locale) {

    if(!locale){
        return false;
    }

    var validLocales = [];

    // concat all locales into single array
    for (var p in teslaMarkets) {
        validLocales = validLocales.concat(teslaMarkets[p].locales);
    }

    return validLocales.indexOf(locale) > -1;
}

/**
 * Returns expected locale given a market and language. Returns default locale for market if language is not passed
 * @return {String}
 */
function getMarketLocale(market, language) {

    var market = teslaMarkets[market];

    if(market){

        var locales = market.locales || [__defaultLocale];     

        if(language) {        
            var matchedLocale = locales.filter(function(locale){
                return locale.substring(0,2) === language;
            });
            
            return matchedLocale.length ? matchedLocale[0] : locales[0];
        }
        // first locale is default
        return locales[0];
    }

    // If no valid locale is found, return default locale: 'en_US'
    return __defaultLocale;
}

/**
 * Gets the default locale for a particular language code
 * @param  {String} language
 */
function getDefaultLocaleForLanguage(language){
    var defaultMarket = languageMap.language[language]
    if(defaultMarket) {
        return language + "_" + defaultMarket
    }
    return __defaultLocale
}


/**
 * Get the proper format for the passed currency code
 * @param  {String} currencyCode
 * @return {Object)
 */
function getLocaleByCurrencyCode(currencyCode){
    for(var market in currencyCodeMap) {
        if(currencyCodeMap[market].code === currencyCode){
            return getMarketLocale(market)
        }
    }
    return undefined;
}

/**
 * Return formatting object for locale (found in 'data/number_format_config.json')
 * @param  {String} locale - locale code
 * @return {Object}
 */
function getLocaleFormat(locale){

    locale = locale || __selectedLocale;
    return NumberFormat.getLocaleFormat(locale);
}


/**
 * Returns markets that Tesla sells in (or that match filter)
 * @param {Object} filters markets
 * @return {Object}
 */
function getMarkets(filter) {

    var markets = _clone(teslaMarkets);

    if (filter) {

        var marketArray = [];

        for (var m in markets) {
            var market = markets[m];
            market.countryCode = m;
            marketArray.push(market);
        }

        marketArray = _filter(marketArray, filter);

        // convert back to map
        return _pick(markets, _map(marketArray, 'countryCode'));
    }

    return teslaMarkets;
}

/**
 * Returns true/false if the market is a right-hand-drive market
 * @param  {String}  marketCode two-letter ISO country code for Tesla market (US, DE, MX, JP, etc)
 * @return {Boolean}
 */
function isRHD(marketCode) {
    var rhdMarkets = getRHDMarkets();
    return rhdMarkets[marketCode] ? true : false;
}

/**
 * Get right-hand-drive markets
 * @param {Boolean} keys - returns array of market codes if true
 * @return {Object} object with market codes as keys
 */
function getRHDMarkets(keys) {
    var markets = getMarkets({
        rhd: true
    });
    return keys ? _keys(markets) : markets;
}

/**
 * Return the associated super region given a countryCode or get all super regions if no countryCode is passed
 * Note: Only countryCodes that are Tesla supported markets are supported
 * @param countryCode {String} two-letter country code
 * @return {Array | Object}
 */
function getSuperRegion(countryCode) {

    if (countryCode) {

        for (var p in superRegions) {
            var superRegion = superRegions[p];
            if (superRegion.markets.indexOf(countryCode) > -1) {
                return _assign(superRegion, {
                    code: p
                });
            }
        }
    }
    else {
        return superRegions;
    }
}

/**
 * Checks to see if regionCode is a valid code for this market
 * @param  {String}  regionCode) code for state/province/territory/etc
 * @return {Boolean}
 */
function isSupportedRegion(regionCode){
   var locale = Utils.parseLocale(__selectedLocale);
   var regions = Location.getAddressByCountryCode(locale.country);
   return (regions[regionCode]) ? true : false;
}

/**
 * Proxy for moment().format()
 * @param  {Date} date   - if undefined, then todays date is used
 * @param  {String} fmt  - date format string like YYYY-MM-DD]
 * @return {String}      - returns formatted date/time string
 */
function formatDate(dte, fmt) {

    if (arguments.length === 1) {
        fmt = arguments[0];
        dte = new Date();
    }

    if(!fmt || fmt.length === 0) {
        var cfg = momentConfig.getLocaleSettings(__selectedLocale)
        if(cfg){
           fmt = _get(cfg, 'longDateFormat.LL', 'LL');
        }
    }

    return moment(dte).format(fmt);
}

/**
 * Formats price
 * @param {Number} num - number to be formatted
 * @param {String} fmt - price format string [defaults to 'm] ('m' = monthly)
 * @return {String} - formatted number
 */
function formatMonthlyPrice(num, fmt){

    fmt = fmt || 'm';

    var localizedPriceFormat = _get(intervalPriceFormat, __selectedLanguage + '.' + fmt);

    return replaceVars(localizedPriceFormat, {AMOUNT: NumberFormat.formatCurrency(num)});
}


/**
 * Accepts a en_US month name and returns localized month name
 *
 * USAGE:
 *
 *  lang.setLocale('de_DE');
 *  expect(lang.getLocalizedMonth('January')).to.equal('Januar');
 *  // with search flag set to true
 *  expect(lang.getLocalizedMonth('Late January', true)).to.equal('Late Januar');
 *
 * NOTE: Developer will need to parse out and localize any text other
 *       than the monthName (e.g. Early | Mid | Late) either before or after calling getLocalizedMonth
 *
 * @param  {String} monthName - English month (January, February, March, etc)
 * @param  {String} search - if present, monthName is searched for a valid month and replaced with localized equivalent.
 * @return {String} string with localized monthName
 */
function getLocalizedMonth(monthName, search) {

    var months = momentConfig.getLocaleSettings('en_US').months;
    var mIndex = -1;

    if (search) {
        for (var i = 0, n = months.length; i < n; i++) {
            if (monthName.indexOf(months[i]) > -1) {
                mIndex = i;
                break;
            }
        }
    }
    else {
        mIndex = months.indexOf(_trim(monthName));
    }

    if (mIndex === -1) {
        console.warn(monthName, ' not found - no localization occurred');
        return monthName;
    }
    else {
        var locale = momentConfig.getLocaleSettings(__selectedLocale);
        return (search) ? monthName.replace(months[mIndex], locale.months[mIndex]) : locale.months[mIndex];
    }
}

/**
 * Get localized Month Name
 * @param  {Numnber} monthIndex - zero-based month index
 * @param  {String} format  - 'short' or 'long', defaults to 'long'
 * @return {String}
 */
function getMonthName(monthIndex, opts) {

    opts = opts || {}

    var format = opts.format || 'long';

    var settings = momentConfig.getLocaleSettings(opts.locale || __selectedLocale);
    var months = format === 'long' ? settings.months : settings.monthsShort || settings.months;
    var monthName = null;

    if(typeof monthIndex === 'number' && monthIndex < months.length){
        monthName = months[monthIndex];
    }
    else {
        console.error('Invalid Month Index');
    }

    return monthName;
}

/**
 * Returns date object with parts split out
 * @param {Date} JS object or ISO 8601 date string
 * @param {Object} opts -- options { locale: 'en_US'}
 * @return {Object}
 */
function getDateParts(dte, opts){

    opts = opts || {};

    var mDte = moment(dte);
    var locale = opts.locale || __selectedLocale;
    var settings = momentConfig.getLocaleSettings(locale);
    var days = settings.weekdays;

    // date parts
    var date = mDte.date();  // day of month
    var day = mDte.day();    // day of week
    var month = mDte.month();
    var year = mDte.year();
    
    // Date String Names
    var monthName = getMonthName(month, { locale: locale});
    var dayName = days[day];
 
    // Month Indicator
    var daysInMonth = mDte.daysInMonth();
    var monthIndicatorNum = date / daysInMonth;
    var monthIndicator = "";

    // It's up to the developer to localize these strings
    if(monthIndicatorNum <= .33) {
        monthIndicator = "early";
    }
    else if (monthIndicatorNum > .33 && monthIndicatorNum < .66){
         monthIndicator = "mid";
    }
    else if(monthIndicatorNum >= .66) {
        monthIndicator = "late";
    }

    return {
        dayName: dayName,
        monthName: monthName,
        month: month,
        date: date,
        day: day,
        year: year,
        daysInMonth: daysInMonth,        
        monthIndicator: monthIndicator
    }
}

/**
 * Get sequence of dates. 
 * 
 * USAGE: 
 *     lang.getDateSequence({startDate: '2018-06-01', step: 'month', count: 3, format: 'YYYY MMMM'}) = [
 *         {label: '2018 June'},
 *         {label: '2018 July'},
 *         {label: '2018 August'}
 *     ]
 * 
 * See related unit tests for additional usage details
 * @param {Date} opts.startDate [date to begin date sequence, defaults to todays date]
 * @param {String} opts.format   [Date Format]
 * @param {String} opts.count [Number of items in sequence]
 * @param {String} opts.step enum ['d', 'm', 'y'] [Amount to increment each date in sequence]
 * @return {Array} [Array of dates]
 */
function getDateSequence(opts){

    opts = opts || {};

    var startDate = opts.startDate || new Date();
    var count = opts.count;
    var date = moment(startDate).clone();
    var fmt = opts.format || 'YYYY-MM-DD';
    var sequence = [{
        label: moment(date).format(fmt)
    }].concat(_times(opts.count -1 ,function(index){

        date = moment(date).clone();

         switch(opts.step || 'month') {
             case 'day':             
                date = moment(date).add(1, 'days');
                break;
             case 'month':
                date = moment(date).add(1, 'months');
                break;
             case 'year':
                 date = moment(date).add(1, 'years');
                 break;               
         }

         return Object.assign({
            date: date,
            label: moment(date).format(fmt)
         });
    }))

    return sequence;
}


/**
 * NOTE: This method not meant to be used on the server, only the client.
 * Some refactoring will be needed to be thread safe
 *
 * This method enables you to easily grab strings needed for your
 * view and will do var replacement
 * Usage:
 *
 * @param key - [required] path to string you need
 * @param vars - optional (Object) map to use for var replacement
 * @param strings - optional (Object) lookup object use instead of __localeStrings if you have scoped it
 * @param opts - optional (Object) other params
 *     returnNullWhenEmpty - returns null instead of an empty string if translation is for key is missing
 *     plural -- see comments below
 */
function getString(key, vars, strings, opts) {

    strings = strings || __localeStrings[__selectedLocale];
    opts = opts || {};

    var str;

    if(!strings){
        throw new Error('getString requires strings to be set with setStrings after a call to setLocale');
    }

    if(arguments.length === 0){
        return strings;
    }

    if (!key) {
        console.error('lang.i18n requires valid key');
        return null;
    }

    str = _get(strings, key, key);

    if(str && opts.plural){
        str = __getPluralizedForm(str, opts);
    }

    if (str && vars) {
        str = replaceVars(str, vars);
    }

    if(opts.returnNullWhenEmpty){
        return (str === key) ? null : str;
    }

    return str;

}

/**
 * Handle pluralized forms
 * Your key/value should look like the following
 * {
 *    "myVarName": {
 *        "default": "One or more vehicle(s) available"
 *        "pluralForms": {
 *            "zero": "No vehicles available",
 *            "single": "One vehicle available",
 *            "multiple": "Some vehicles available",
 *            "count": "{count} vehicles available",
 *            "gt" "Many vehicles available",
  *           "lt" "A few vehicles available"
 *        }
 *     }
 * }
 *
 * Note: pluralForms keys listed above are optional
 * See related unit tests for more details
 *
 * @param strings
 * @param opts
*/
function __getPluralizedForm(strings, opts){

    var str;

    // if strings is not an object, skip the plural forms logic
    if(_isObject(strings)){
        // check if count is defined
        if(_has(opts, 'count')){
            var n = opts.count;
            var pf = strings.pluralForms || {};

            // is there a zero format?
            if(n === 0 && pf.zero){
                str = pf.zero;
            }
            // single form
            else if(n === 1 && pf.single){
                str = pf.single;
            }
            // multiple form(s)
            else if(n > 1 && pf.multiple){
                str = pf.multiple;
            }
            else if (n > 1 && pf.count){
                str = pf.count;
            }

            // if count is > gt
            if(opts.gt && (n > opts.gt) && pf.gt){
                str = pf.gt;
            }

            // if count is < lt
            if(opts.lt && (n < opts.lt) && pf.lt){
                str = pf.lt;
            }
        }

        if(!str){
            str = strings.default;
        }
    }
    else {
        return strings
    }

    return str;
}


/**
 * Sets strings map for current locale
 * NOTE: This method not meant to be used on the server, only the client.
 * Some refactoring will be needed to be thread safe
 *
 * @param {Object} strings
 */
function setStrings(strings) {
    __localeStrings[__selectedLocale] = strings;
}

/**
 * If a string bundle has been set via setStrings, return it
 * @return {Object}
 */
function getBundle(){
    return __localeStrings[__selectedLocale];
}

/**
 * Helper function for string variable replacement
 *
 * USAGE:
 *
 * var str = 'Tesla has free {VAR_NAME} for you to {VERB}'
 * Tesla.DesignStudio.lang.replace(str,{VAR_NAME:'apples', VERB:'eat'})
 * Returns 'Tesla has free apples for you to eat'
 *
 * @param {String} str string that has vars that you want to replace
 * @param {Object} vars
 * @returns {String}
 */
function replaceVars(str, vars) {

    if (str && vars) {

        var re = /{\w+}/g;
        var matches = str.match(re);

        if (!matches) {
            return str;
        }

        for (var i = 0, n = matches.length; i < n; i++) {
            var prop = matches[i].substring(1, matches[i].length - 1);
            if(vars[prop]) {
                str = str.replace(matches[i], vars[prop]);
            }
            else {
                 str = str.replace(matches[i], '');
            }
        }
    }

    return str;
}

/**
 * Formats all numeric values found in obj as formatType ( number OR currency )
 *
 * Example:
 *
 *    lang.formatNumericValues({a: 123.5, b: 1234, c: 1}, 'currency')
 *    returns {a: '$124', b: '$1,234', c: '$1'}
 *
 * @param {Object} obj object that you want to format values of
 * @param {String} formatType ('number'|'currency')
 * @return {Object} returns new object with same keys as passed object, but
 * with all numeric values formatted
 */
function formatNumericValues(obj, formatType) {

    var out = {};

    for (var p in obj) {

        var val = obj[p];

        if (!isNaN(parseFloat(val))) {

            if (formatType === undefined || formatType === 'number') {
                out[p] = this.formatNumber(val);
            }
            else if (formatType === 'currency') {
                out[p] = this.formatCurrency(val);
            }
        }
        else {
            // just dump non numeric values back to output object
            out[p] = val;
        }
    }

    return out;
}

/**
 * Return list of items, separated by opts.delimiter
 * with final item formatted in various ways:
 *
 *   formatList([A,B,C]) => 'A, B, C'
 *   formatList([A,B,C], {and: treue}) => 'A, B, and C'
 *
 * @param  {Array<String} arr
 * @param  {Object} opts - options [delimiter, and]
 * @return {String} - list formatted as string
 */
function formatList(arr, opts){

    opts = opts || { delimiter: ',', and: false };

    var delimiter = opts.delimiter || ',';
    var listStrings = list[__selectedLanguage] || { and: '' };
    var str = '';

    for(var i = 0; i < arr.length; i++){
        if(i === arr.length - 1){
            if(opts.and){
                str += listStrings.and + ' ' + arr[i];
            }
            else {
                str += arr[i];
            }
        }
        else {
          str += arr[i] + ', '
        }
    }

    return str;
}

/**
 * Convert string number to float
 * @param  {String} currencyValue -- formatted string number
 * @return {Number} converts currency string to float
 */
function toFloat(currencyValue, locale){

    var num = currencyValue;
    var localeFormat = getLocaleFormat(locale);

    // escape the .
    var thousandSeparator = localeFormat.thousand.replace('.', '\\.')
    var thousandsRx = new RegExp(thousandSeparator, 'g')

    // strip out any currency symbols
    if(typeof num === 'string'){
        num = num.replace(localeFormat.symbol, '');
        num = num.replace(thousandsRx, '');
        num = num.replace(localeFormat.decimal, '.');
    }

    num = parseFloat(num);

    return num;
}


// -- exports
module.exports = {

    currencyCodeMap: currencyCodeMap,
    getLocaleByCurrencyCode: getLocaleByCurrencyCode,
    get: getString,
    getBundle: getBundle,
    setLocale: setLocale,
    getMarketLocale: getMarketLocale,
    getDefaultLocaleForLanguage: getDefaultLocaleForLanguage,
    setStrings: setStrings,
    replace: replaceVars,
    isSupportedLocale: isSupportedLocale,
    isSupportedRegion: isSupportedRegion,
    parseLocale: Utils.parseLocale,
    getMarkets: getMarkets,
    getSuperRegion: getSuperRegion,
    getRHDMarkets: getRHDMarkets,
    isRHD: isRHD,
    formatNumericValues: formatNumericValues,
    formatList: formatList,

    // -- Date Utils --
    getLocalizedMonth: getLocalizedMonth,
    getDateSequence: getDateSequence,

    /**
     * TODO: Gather list of most common date formats in use by Tesla applications
     * Common Date Formats
     * @type {Object}
     */
    dateFormats: {
        // ISO 8601 Formats @see  https://en.wikipedia.org/wiki/ISO_8601
        'iso_date': 'YYYY-MM-DD',
        'iso_date_basic': 'YYYYMMDD',
        'iso_timestamp': 'YYY-MM-DD hh:mm:ss',
    },

    // format date via moment
    formatDate: formatDate,

    // get localized month name
    getMonthName: getMonthName,

    // get parts of dates
    getDateParts: getDateParts,

    /**
     * @see toFloat
     * @type {Function}
     */
    toFloat: toFloat,

    /**
     * @see NumberFormat.formatCurrency
     * @type {Function}
     */
    formatCurrency: NumberFormat.formatCurrency,

    /**
     * @see NumberFormat.formatCreditCard
     * @type {Function}
     */
    formatCreditCard: NumberFormat.formatCreditCard,

    /**
     * @see NumberFormat.formatCreditCard
     * @type {Function}
     */
    formatExpirationDate: NumberFormat.formatExpirationDate,

    /**
     * @see NumberFormat.formatNumber
     * @type {Function}
     */
    formatNumber: NumberFormat.formatNumber,

    /**
     * @see NumberFormat.formatPercent
     * @type {Function}
     */
    formatPercent: NumberFormat.formatPercent,

    /**
     * Format monthly price
     * @type {String}
     */
    formatMonthlyPrice: formatMonthlyPrice,

    /**
     * @see NumberFormat.setCurrencyPrecision
     * @type {Function}
     */
    setCurrencyPrecision: NumberFormat.setCurrencyPrecision,

    /**
     * Return formatting object for locale (found in 'data/number_format_config.json')
     * @param  {String} locale - locale code
     * @return {Object}
     */
    getLocaleFormat: getLocaleFormat
};

