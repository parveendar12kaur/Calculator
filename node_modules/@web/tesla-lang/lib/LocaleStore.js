/* global window */
'use strict';

/**
 * Locale store implementation
 * Provides simple translation abilities for your React Components
 * 
 * Usage: For use in applications using commonjs modules
 * You must inject your translations via the setStrings method that accepts a JSON object of translated strings
 *
 * TODO: 
 *    build ability to load translations on demand
 *
 * @author Frank Young
 */
var _ = require('lodash'),
    NumberFormat = require('./NumberFormat'),
    EventEmitter = require('events').EventEmitter;

var LocaleStore = Object.assign({}, EventEmitter.prototype, {

    __strings: null,
    __locale: 'en_US',

    /**
     * Sets locale
     * @param {String} locale
     * @emits localeChanged event
     */
    setLocale: function(locale){

        this.__locale = locale;
        NumberFormat.setLocale(locale);
        this.emit('localeChanged', locale);
    },

    /**
     * Return locale strings
     *
     * @returns {null|*}
     */
    getStrings: function(){
        var strings = this.__strings ? this.__strings : (typeof window !== 'undefined') ? window.tesla.strings : {};
        return strings;
    },

    /**
     * Sets json object of strings
     * @param strings
     */
    setStrings: function(strings){
        this.__strings = strings;
    },

    /**
     * This method enables you to easily grab strings needed for your
     * view and will do var replacement
     *
     * If opts.root is passed, this method will be scoped to whatever path it is set to
     *
     * Usage:
     *
     * @param key - required
     * @param opts - optional (Object) [strings,vars,formatAsCurrency]
     */
    get: function(key, opts){

        opts = opts || {};

        var root = opts.root;
        var vars = opts.vars ? opts.vars : opts;
        var strings, str;

        if(!key){
            console.error('lang.i18n requires valid key');
            return null;
        }

        if(root){
            strings = _.get(this.__strings, root);
        }
        else{
            strings = this.__strings;
        }

        str = _.get(strings, key, key);

        if(str && vars){
            str = this.replace(str, opts.vars);
        }

        return str;

    },

    /**
     * Helper function for string variable replacement
     *
     * USAGE:
     *
     * var str = 'Tesla has free {VAR_NAME} for you to {VERB}'
     * Tesla.DesignStudio.lang.replace(str,{VAR_NAME:'apples', VERB:'eat'})
     * Returns 'Tesla has free apples for you to eat'
     *
     * @param {String} str string that has vars that you want to replace
     * @param {Object} vars
     * @returns {String}
     */
    replace: function(str, vars){

        if(str && vars){

            var re = /{\w+}/g;
            var matches = str.match(re);

            if(!matches){
                return str;
            }

            for(var i = 0, n = matches.length; i < n; i++){
                var prop = matches[i].substring(1, matches[i].length - 1);
                str = str.replace(matches[i], vars[prop]);
            }
        }

        return str;
    },    

    /**
     * Returns returns the proper translation key for plural vs singular words
     * Note: Your string map must have keys for both:
     *        Experimenting with this approach, have to see how it actually applies to ready world translations
     *
     *  Example: 
     *  
     *    strings.json:
     *    {
     *       'oneInverter' : '1 Inverter'
     *       'numInverters' : '{numInverters} Inverters'
     *    }
     *
     *    // returns '1 Inverter'
     *    LocaleStore.getGrammaticalNumber('numInverters', 1 ,{numInverters: 1});
     *     
     *    // returns '4 Inverters'
     *    LocaleStore.getGrammaticalNumber('numInverters', 4 ,{numInverters: 4});
     * 
     * @param  {String} key tranlation key
     * @param  {Number count number of items
     * @return {string}
     */
    getGrammaticalNumber: function(key, count, vars, opts){

        opts = opts || {};

        var pluralPrefix = opts.pluralPrefix || 'num';
        var singularPrefix = opts.singularPrefix || 'one';

        var hasPluralPrefix = new RegExp(pluralPrefix);

        if(count === 1){

            if(hasPluralPrefix.test(key)){
                key = key.replace(pluralPrefix, singularPrefix);
            }

            if(key.charAt(key.length - 1) === 's'){
                key = key.substring(0, key.length - 1);
            }
        }

        return this.get(key, {vars: vars});
    },

    /**
     * Takes a number and returns localized format
     * @param  {Number} num
     * @see  NumberFormat.formatNumber
     * @return {String}     [formatted number]
     */
    formatNumber: NumberFormat.formatNumber,

    /**
     * Takes a number and returns it formatted as currency
     * @see  NumberFormat.formatCurrency
     * @param  {Number} num
     * @return {String}     [returns number formatted as currency]
     */
    formatCurrency: NumberFormat.formatCurrency,

    // alias -- for backward compatibility
    formatAsCurrency: NumberFormat.formatCurrency,
    
    /**
     * @see NumberFormat.setCurrencyPrecision
     * @type {Function}
     */    
    setCurrencyPrecision: NumberFormat.setCurrencyPrecision,

    /**
     * Formats number and appends units to formatted value
     * @param  {Number} num   number
     * @param  {String} units kW,kWh,hours, miles, etc...
     * @return {String}       returns formatted value
     */
    formatValue: function(num, units, precision){
        return this.formatNumber(num, precision) + ' ' + units;
    },

    /**
     * Return formatting object for locale (found in 'data/number_format_config.json')
     * @param  {String} locale - locale code
     * @return {Object} 
     */
    getLocaleFormat:function(locale){
        return NumberFormat.getLocaleFormat(locale); 
    }

});

module.exports = LocaleStore;