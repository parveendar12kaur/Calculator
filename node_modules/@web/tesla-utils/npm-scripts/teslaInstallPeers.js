#! /usr/bin/env node

/**
 * TESLA-INSTALL-PEERS
 *
 * Installs your modules peerDependencies, then iterates through those peerDependencies
 * and installs any additional missing dependencies
 *
 * ISSUE: You are working on a sub-module that has peerDependencies that are handled by the parent module, but
 * you need the module to work on this module independently for your unit tests to work.
 *
 * What this script does NOT do:
 *  - Any checking of module versions, you will have to verify you have the proper versions of peerDepdencies installed
 */

const fs = require('fs');
const child_process = require('child_process');
const path = require('path');
const _ = require('lodash');
const async = require('async');
const colors = require('colors');

// grab package of calling module
const pkg = require(path.join(process.cwd(), "package.json"));

// maps to store dependency check lists
const peerDependenciesMap = {};
const peerDependenciesToInstall = {};

/**
 * Generates npm install command string
 * @param  {Object} deps [Object with peerDependencies you need to install]
 * @return {String}      [npm install command]
 */
function createPeerInstallCommand(deps) {

    let cmd = 'npm install';
    _.forOwn(deps, (version, moduleName) => {
        if (!peerDependenciesMap[moduleName]) {
            // store in map
            peerDependenciesMap[moduleName] = version
            cmd += ` "${moduleName}@${version}"`;
        }
    });

    console.info('\nINSTALLING PEERS'.yellow);
    console.info(cmd.yellow);
    console.info('...\n'.yellow);

    return cmd;
}

/**
 * Get actual install versions
 * @param  {Object} peerDependencies
 * @return {Object}
 */
function getInstalledVersions(peerDependencies, callback) {

    const moduleNames = _.keys(peerDependencies);
    const requests = {};
    const result = {};

    // read version # from each modules package.json
    moduleNames.forEach((module) => {
        requests[module] = (cb) => {
            let filePath = path.join(process.cwd(), 'node_modules', module, 'package.json');
            fs.readFile(filePath, 'utf-8', (err, data) => {
                cb(err, data);
            });
        }
    })

    async.parallel(requests, (err, response) => {
        if (err) {
            console.info('Error trying to read package.json of peerDependencies'.red, err);
        }
        else {
            _.forOwn(response, (pkg, key) => {
                let v = JSON.parse(pkg).version;
                result[key] = v;
            });
            if (callback) {
                callback(err, result);
            }
        }
    })
}

/**
 * Run npm install command
 * @param  {String}   cmd [npm install command string]
 * @param  {Function} cb  [callback]
 */
function doInstall(cmd, cb) {
    child_process.exec(cmd, (error, stdout, stderr) => {
        if (error) {
            console.error('Error installing peerDependencies'.red, error);
        }
        else {
            cb(error)
        }
    })
}

/**
 * Checks the installed peerDependency packages for their own peerDependencies and ensures we aren't missing anything
 * @param  {Object} deps [map of peerDependencies to check]
 * @param  {Function} cb   [callback]
 */
function checkInstalledPeers(deps, cb) {

    const requests = {};

    _.forOwn(deps, (version, moduleName) => {
        requests[moduleName] = (cb) => {
            let filePath = path.join(process.cwd(), 'node_modules', moduleName, 'package.json');
            fs.readFile(filePath, 'utf-8', (err, data) => {
                cb(err, data);
            });
        }
    });

    async.parallel(requests, (err, response) => {
        if (err) {
            console.log(err);
            cb(err);
        }
        else {
            _.forOwn(response, (pkg, key) => {
                if (key.match(/@web|@tesla/)) {
                    let peers = JSON.parse(pkg).peerDependencies;
                    _.forOwn(peers, (v, m) => {
                        try {
                            // check if we've already installed it
                            if (!peerDependenciesMap[m]) {
                                if (!peerDependenciesToInstall[m]) {
                                    peerDependenciesToInstall[m] = v;
                                }
                            }
                        }
                        catch (err) {
                            console.error(err);
                            return;
                        }
                    });
                }
            });

            cb(err, peerDependenciesToInstall);
        }
    })
}

// INSTALL FIRST-LEVEL PEERS
doInstall(createPeerInstallCommand(pkg.peerDependencies), (err) => {

    getInstalledVersions(pkg.peerDependencies, (err, result) => {
        console.info('MODULES INSTALLED'.cyan);
        console.info(JSON.stringify(result, null, 4).cyan);
    });

    // INSTALL SECOND-LEVEL PEERS... this should be enough hopefully... it better be...
    checkInstalledPeers(pkg.peerDependencies, (err, result) => {
        if (!_.isEmpty(peerDependenciesToInstall)) {
            doInstall(createPeerInstallCommand(peerDependenciesToInstall), (err) => {
                if (!err) {
                    getInstalledVersions(peerDependenciesToInstall, (err, result) => {
                        console.info('MODULES INSTALLED'.cyan);
                        console.info(JSON.stringify(result, null, 4).cyan);
                        console.info('PEER DEPENDENCY INSTALL COMPLETE!'.bold.green);
                    });
                }
            });
        }
        else {
            console.info('PEER DEPENDENCY INSTALL COMPLETE!'.green);
        }
    })
})
