"use strict";

var _ = require("lodash");

/**
 * Wrapper for Browser Storage
 *
 * @author Frank Young
 *
 * Why you should use it:
 * - allows you to set an expires time for cached values
 * - automatically handles serialization/deserialization of stored objects
 * - safely adds key/values to storage (clears storage first if it throws 'too large' exception)
 * - allows you to easily toggle between localStorage and sessionStorage, depending on your needs
 * - supports validation with custom callback
 *
 * @scope - should be 'window'
 */
module.exports = function Storage(scope){

    var __localStorage = scope.localStorage,
        __sessionStorage = scope.sessionStorage,

        // default to localStorage
        __storage = __localStorage,

        // disable with Storage.disable()
        __enabled = true,

        // if a set attempt fails due to storage being full, we'll clear expired entries and try again
        __setAttempts = 0,
        __maxSetAttempts = 2,
        __expiresMap = {
            "second": 1000,
            "minute": 1000 * 60,
            "hour"  : 1000 * 60 * 60,
            "day"   : 1000 * 60 * 60 * 24,
            // the way things work around here, a week will be the longest anything should be cached
            "week"  : 1000 * 60 * 60 * 24 * 7,
            // or an eternity in tesla-time
            "month"  : 1000 * 60 * 60 * 24 * 30
        };

        if(! __storage){
            //console.error('No localStorage found!!!');
            __enabled = false
        }

    /**
     * Returns expires time in milliseconds
     * @param expires
     */
    function __getExpiresTime(expires){

        var ts = new Date().getTime();

        if(_.isString(expires)){
            if(_.has(__expiresMap, expires)){
                ts += __expiresMap[expires];
            }
        }
        else if(!isNaN(expires) && _.isNumber(expires)){
            ts += expires;
        }
        else{
            //console.error("Storage.set error [incorrect expires option " + expires + "]");
        }

        return ts;
    }

    var inst = {

        duration: __expiresMap,

        /**
         * Sets  name/value pair in storage
         *
         * opts param allows the following properties:
         *     - expires
         *     - tags (if for some reason you need to store meta about the stored value)
         *
         * @param key {String}
         * @param value {String,Number or Object}
         * @param opts {Object}
         */
        set: function(key, value, opts){

            // if Storage is disabled for some reason, return null
            if(!__enabled) {
                return null;
            }

            opts = opts || {};

            var data = {
                value    : value,
                type     : typeof value,
                timestamp: new Date().getTime(),
                version  : opts.version || null
            };

            // set expires property
            if(_.has(opts, "expires")){
                data.expires = __getExpiresTime(opts.expires);
            }

            if(value === undefined){
                // console.warn("Storage.set undefined value was cached! " + value);
            }

            __setAttempts++;

            try{
                // Safely set localStorage value
                if(__setAttempts <= __maxSetAttempts){
                    __storage.setItem(key, JSON.stringify(data));
                    this.length = __storage.length;
                }

                // success!! set counter back to zero
                __setAttempts = 0;

            }
            catch (err){

                // console.warn('error trying to set value in storage, storage available likely exceeded ' + key, err);
                // let's remove any expired entries
                this.purgeExpiredItems();

                // try to set again
                this.set(key, value, opts);

            }
        },

        /**
         * Returns a value that was stored if it exists and has not expired
         * @param key
         * @param {Function} validateFunc -- optional function to validate cached data before returning
         */
        get: function(key, validateFunc){

            // if Storage is disabled for some reason, return null
            if(!__enabled) {
                return null;
            }

            var data = __storage.getItem(key),
                now = new Date().getTime(),
                expires,
                value = null;

            try{
                data = JSON.parse(data)
            }
            catch(err){
                // console.log('error trying to parse localStorage value', key);
            }

            if(data){

                if(_.isFunction(validateFunc) && validateFunc(data) === false){
                    return null;
                }

                expires = data.expires || now;

                // make sure it hasn't expired
                if(expires >= now){

                    switch(data.type){

                        case 'object':
                        case 'string':
                            value = data.value;
                            break;
                        case 'number':
                            value = parseFloat(data.value);
                            break;
                        default:
                            value = data.value;
                            break;
                    }
                }
            }

            return value;

        },

        /**
         * Will merge previously cached object with new data (if key is found)
         *
         * Note: Be cautious while using this if you are trying to merge complex objects
         *
         * @param  {String} key
         * @param  {Object} data
         * @param  {Object} opts -- [optional props like version, expires, etc]
         */
        merge: function(key, dataToMerge, opts) {

            // if Storage is disabled for some reason, return null
            if(!__enabled) {
                return null;
            }

            var cache = __storage.getItem(key);

            if(cache){

                cache = JSON.parse(cache);

                _.merge(cache.value, dataToMerge);

                // keep all opts from original data
                var cacheOpts = {
                   expires  : cache.expires || Date.now(),
                   type     : cache.type,
                   timestamp: cache.timestamp,
                   version  : cache.version
                }

                this.set(key, cache.value, _.merge(cacheOpts, opts || {}));
            }
            else {
                this.set(key, dataToMerge, opts);
                //console.info('Storage.merge: key', key, ' not found, creating new key');
            }
        },

        /**
         * Removes name/value pair
         * @param key
         */
        remove: function(key){

            // Only remove item if Storage is enabled
            if(__enabled) {
                __storage.removeItem(key);
                this.length = __storage.length;
            }
        },

        /**
         * Returns true/false if name/value pair exists
         * @param {String} key
         * @param {Function} fn -- function used to validate cache before returning
         */
        exists: function(key, fn){
            var value = this.get(key, fn);
            return value !== null ? true : false;
        },

        /**
         * Alias for exists(key)
         * @param {String} key
         * @param {Function} fn -- function used to validate cache before returning
         */
        has: function(key, fn){
            return this.exists(key, fn);
        },

        /**
         * Return any keys that exist in localStorage
         * @return {Array} [description]
         */
        keys: function(){

            var keys = [];
            for ( var i = 0, n = __storage.length; i < n; ++i ) {
                keys.push(__storage.key( i ))
            }

            return keys;
        },

        /**
         * Clears storage
         */
        clear: function(){

            // Only clear if Storage is enabled
            if(__enabled) {
                __storage.clear();
            }
        },

        /**
         * removes any expired items in storage
         */
        purgeExpiredItems: function(){

            var now = new Date().getTime(), i, key, item;

            for(i = 0; i < __storage.length; i++){
                key = __storage.key(i);
                item = __storage.getItem(key);
                if((item.timestamp + item.expires) < now){
                    __storage.removeItem(key);
                }
            }
        },

        /**
         * Disable getting cache
         * values will still be stored localStorage, but Storage.get(key) will return null while disabled
         */
        disable: function(){
            __enabled = false;
        },

        /**
         * Sets the type of storage we are using ("session" or "local", defaults to "session")
         */
        setType: function(storageType){

            if(storageType === "session" && __sessionStorage){
                __storage = __sessionStorage;
            }
            else if(storageType === "local" && __localStorage){
                __storage = __localStorage;
            }
        }

    };

    return inst;

}(typeof window === "undefined" ? global : window);