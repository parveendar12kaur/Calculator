"use strict";

// Please keep ES5 friendly for time being

var _ = require('lodash');

/**
 * TeslaOrderUtils module
 * Contains utility methods to help with validation, transforming and analyzing common
 * vehicle order and configuration data
 *
 * @author Frank Young
 */

module.exports = {

    /**
     * Is the value a reservation number?
     * @param val
     * @returns {boolean}
     */
    isRN: function(val){
        return val && (val.match(/^RN\d{6,}$/) ? true : false);
    },

    /**
     * Is the value a VIN number?
     *
     * @param val
     * @returns {boolean}
     */
    isVIN: function(val){
        // All Tesla VINs begin with:
        var teslaVINPrefix = '5YJ';
        return val &&
               val.length >= 10 &&
               val.length < 18 &&
               val.substring(0,3) === teslaVINPrefix &&
               this.isAlphanumeric(val);
    },

    /**
     * Is the value a LCID?
     *
     * @param {string} val
     * @returns {boolean}
     */
    isLCID: function(val) {
        return val && val.indexOf('LCID') !== -1 && this.isAlphanumeric(val)
    },

    /**
     * determines whether a string is alphanumeric or not
     * @param  {String}       str to be test
     * @return {Boolean}
     */
    isAlphanumeric: function(str) {
        for (var char in str ) {
            var code = str.charCodeAt(char);
            if (!(code > 47 && code < 58) && // numeric (0-9)
                !(code > 64 && code < 91) && // upper alpha (A-Z)
                !(code > 96 && code < 123)) { // lower alpha (a-z)
              return false;
            }
      }
      return true;
    },

    /**
     * Diff two arrays of options (meant to show before/after differences)
     *
     * Arrays must be simple strings ['OPT1', 'OPT2', etc...]
     *   example: ENGINE.getManufacturingStringAsArray()
     *
     * @param arrBefore {Array<String>}
     * @param arrAfter {Array<String>}
     */
    diff: function(arrBefore, arrAfter){

        var removedOptions = _.difference(arrBefore, arrAfter);
        var addedOptions = _.difference(arrAfter, arrBefore);

        return {
            changed: (removedOptions.length || addedOptions.length),
            addedOptions: addedOptions,
            removedOptions: removedOptions
        };
    },

    /**
     * Returns price difference between two arrays of options with price
     * @param initial, changed
     */
    getOptionsPriceDiff: function(initialOptions, changedOptions){

        var initialOptionsSum = _.sumBy(initialOptions, function(opt){
                return opt.price;
            }),
            changedOptionsSum = _.sumBy(changedOptions, function(opt){
                return opt.price;
            }),
            diff = changedOptionsSum - initialOptionsSum,
            sign = diff < 0 ? "-" : (diff > 0 ? "+" : "");

        return {
            initialOptionsSum: initialOptionsSum,
            changedOptionsSum: changedOptionsSum,
            value: diff,
            sign : sign
        };
    },

    /**
     * Returns array of user selected option codes
     * @returns {Array}
     */
    getUserSelectedOptions: function(options){

        var userSelectedOptions = [];

        for(var opt in options){
            if(options[opt].user_selected){
                userSelectedOptions.push(opt);
            }
        }

        return userSelectedOptions;
    },

    /**
     * Converts optionString to array
     * Removes whitespace if exists
     *
     * @param optionString
     * @param delimiter {String} [optional, defaults to comma ',']
     * @returns {Array<String>}
     */
    optionStringToArray: function(optionString, delimiter){

        // remove any whitespace from optionString
        optionString = optionString.replace(/\s/g, '');
        delimiter = delimiter || ',';

        return optionString.split(delimiter);
    },

    /**
     * Converts array of options to delimited optionsString
     * @param optionArray{Array}

     * @returns {String}
     */
    optionsArrayToOptionsString: function(optionArray){
        // simple array or option objects
       return  (typeof optionArray[0] === 'string') ? optionArray.join(',') : _.map(optionArray, 'code').join(',');
    },

    getManufacturingString: function(optionArray){
        return this.optionsArrayToOptionsString(optionArray);
    },

    /**
     * Converts map of options to delimited optionsString
     * @param optionMap{Object}
     * @returns {String}
     */
    optionsMapToOptionsString: function(optionMap){
        return _.keys(optionMap).join(',');
    },

    /**
     * Returns an options price string
     * @param  {Array} options -- Array of options (must contain fields: [code, price, price_indicator])
     * @return {String}  Returns standard optionsPriceString format:  MLDX|STANDARD|80000;
     */
    getOptionsPriceString: function(options){

        var optionsPriceString = "";

        for(var i = 0, n = options.length; i < n; i++ ){

            var opt = options[i];
            var price_indicator = opt.price_indicator || "INCLUDED";

            optionsPriceString += opt.code + "|" + price_indicator.toUpperCase() + "|" + opt.price;

            if(i < n - 1){
                optionsPriceString += ";";
            }
        }

        return optionsPriceString;
    },

    /**
     * Converts optionPriceString to array of options with price
     * @param optionPriceString
     * @param sort {Boolean} [optional sort flag, sorts options descending if true -- no sort if empty]
     */
    optionPriceStringToArray: function(optionPriceString, sort){

        var optionPriceList = optionPriceString.split(';');
        var options = [];

        for (var i = 0, n = optionPriceList.length; i < n; i++) {

            var optPrice = optionPriceList[i].split("|"),
                code = optPrice[0],
                price_indicator = optPrice[1],
                price = parseFloat(optPrice[2]);

            options.push({
                price_indicator: price_indicator,
                code: code,
                price: price
            });
        }

        if(sort){

            // sort options by opt code
            options.sort(function(a, b){

                var aCode = a.code,
                    bCode = b.code;

                return aCode === bCode ? 0 : (aCode < bCode) ? -1 : 1 ;
            });

        }

        return options;

    },

    /**
     * Takes map or array of options and returns a map with the following:
     * {
     *   BT85: {price: 30000, listPrice: 30000, financedPrice: 444},
     *   OPT2: {price: 7500, listPrice: 7500, financedPrice: 148},
     *   OPT3: {price: 0, listPrice: 0, financedPrice: 0},
     * }
     */
    getOptionsPriceMap: function(options){

        var priceMap = {};

        if(!_.isArray(options)){
            options = _.toArray(options);
        }

        for(var i = 0, n = options.length; i < n; i++ ){

            var opt = options[i];
            priceMap[opt.code] = {
                price: opt.price,
                listPrice: opt.list_price,
                financedPrice: opt.financed_price
            };
        }

        return priceMap;

    },

    /**
     * Return the sum of all option prices
     * @param  {Array | String} options either array of options or options price string
     * @return {Number}
     */
    getOptionsPriceTotal: function(options){

        // optionsPriceString was passed in
        if(typeof options === "string"){
            options = this.optionPriceStringToArray(options);
        }

        var sum = 0;

        for(var i = 0, n = options.length; i < n; i++){
            if(options[i].price){
                sum += options[i].price;
            }
        }

        return sum;
    },

    /**
     * Returns true if options have prices
     * @param  {String | Array}  options [either optionsPriceString or array of option objects]
     * @return {Boolean}
     */
    hasPrices: function(options){
        return this.getOptionsPriceTotal(options) > 0;
    },

    /**
     * Returns true if param 'options' has a length of 2 and
     * are a toggle pair
     * @param options {Array}
     */
    isTogglePair: function(options){

        return (options.length === 2) &&
            (options[0].code === options[1].toggle_pair &&
            options[1].code === options[0].toggle_pair);
    },

    /**
     * Replace one option code with another given an optionString
     *
     * Note: This is not likely to be used in many tools because Configurator.setOption
     *       method should handle the needed functionality, but may be used in some bulk tool functionality
     *       and during development work
     *
     * @param options {Array<String>|String} -- If an array is passed, it should be a simple String[] array
     * @param from {String} [optCode to replace]
     * @param to {String}   [new optCode to be inserted]
     */
    replaceOption: function(options, from, to){

        var isArray = options instanceof Array;
        var optionString = isArray ? options.join(',') : options;
        var optionExists = optionString.search(new RegExp(from)) > -1;

        // if option does not exist, ignore it
        if(optionExists){
            optionString = optionString.replace(from, to);
        }

        if(isArray){
            return optionString.split(',');
        }

        return optionString;
    },

    /**
     * Iterates through selectedOptions array and sets 'selected' flag to true of each matching option found in optionMap
     * @param optionMap {Object}
     * @param selectedOptions {Array}
     */
    setSelected: function(optionMap, selectedOptions){

        for(var i = 0, n = selectedOptions.length; i < n; i++){

            var opt = selectedOptions[i];
            var optCode;

            if(typeof opt === 'string'){
                optCode = opt;
            }
            else{
                optCode = opt.code;
            }

            if(optionMap[opt]){
                optionMap[opt].selected = true;
            }
        }

        return optionMap;
    },

    /**
     * Returns the battery code from an array of options
     * @param { String | Array} options -- if string passed, it is converted to array
     * @return {[type]} [description]
     */
    getBatteryCode: function(options, batteryPattern){

        if(!options){
            console.error('getBatteryCode requires a valid optionString or array of options')
            return false
        }

        // make sure this is updated if new battery code patterns emerge
        batteryPattern = batteryPattern || /((P)?(BT)?(BX)?)(M|X|4|6|7|8)(0|4|5|X)(D)?$/;

        if(typeof options === 'string'){
            options = options.split(",")
        }

        for(var i = 0, n = options.length; i < n; i++){
            if(batteryPattern.test(options[i])){
                return options[i]
            }
        }

        console.warn('no battery code found');
    },

    /**
     * Returns model code from array of option codes
     * @param  {[type]} options [description]
     * @return {[type]}         [description]
     */
    getModelCode: function(options){

        if(typeof options === 'string'){
            options = options.split(",")
        }

        var modelPattern = /(M)?(S)/

        MDLX

        for(var i = 0, n = options.length; i < n; i++){
            if(batteryPattern.test(options[i])){
                return options[i]
            }
        }
    }

};