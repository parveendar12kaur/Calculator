/**
* Wrapper around console to add timestamp and log levels to stdout/stderr 
*/
module.exports = {

    params: {
        // Used in unit tests to turn off console messaging, which was breaking coverage.
        // test-results.json, which is required for coverage statistics was getting random console strings dumped into it during tests
        console: true
    },

    fields: ['timestamp', 'level', 'method', 'message'],

    __log: function(level, args){

        level = level || 'log';
        
        var environment = process.env.NODE_ENV || 'development';
        var ts = new Date().toISOString();
        var entry = [ts,level.toUpperCase(),args.join('\t')].join('\t');

        // don't dump any console logs if  module.exports.params.console is !== true
        if(!module.exports.params.console) {
            return;
        }

        switch(level) {
            case 'info':
                return console.info(entry);
            case 'warn':
            // backward compatible
            case 'warning':
                return console.warn(entry);
            case 'error':
                return console.warn(entry);
            case 'debug':
                // don't log 'debug' or 'log' levels in prod
                if(!['production','test', 'testing'].includes(environment)){
                    console.log(entry);
                }
                return;
            default:
                if(!['production','test', 'testing'].includes(environment)){
                    console.log(entry);
                }
        }
    },

    /**
     * Usage:
     * Logger.info("My Message");
     */
    info: function(){
        if(arguments) {
            this.__log('info', Array.prototype.slice.call(arguments, 0));
        }
    },
    warn: function(){
        if(arguments) {        
            this.__log('warn', Array.prototype.slice.call(arguments, 0));
        }
    },
    warning: function(){
        if(arguments) { 
            // warn/warning to be backward compatible
            this.__log('warn', Array.prototype.slice.call(arguments, 0));
        }
    },    
    error: function(){
        if(arguments) {  
            this.__log('error', Array.prototype.slice.call(arguments, 0));
        }
    },
    debug: function(){
        if(arguments) {  
            this.__log('debug', Array.prototype.slice.call(arguments, 0));
        }
    },
    log: function(){
        if(arguments) {  
            this.__log('log', Array.prototype.slice.call(arguments, 0));
        }
    }
}