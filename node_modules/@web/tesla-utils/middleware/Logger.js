/**
 * Simple Logger module that wraps console.log (similar to ba-debug, but more for node)
 * Produces consistent log messages with timestamps and error levels
 *
 * @author - Frank Young
 *
 * USAGE:
 *
 *   Logger.setApplicationName("FooApp")
 *
 *   Example Info Log
 *     Logger.info("Order sucessfully submitted to MyTesla for RN123456");
 *     LEVEL    TIMESTAMP              APPLICATION_NAME   MESSAGE
 *     INFO    Sept 23, 2015 3:30 PM   FooApp             Order sucessfully submitted to MyTesla for RN123456
 *
 * ---------------------------------------------------------------
 *
 *   Example Error Log
 *     Logger.error(new ServiceError({message: "Error submitting order to MyTesla" , type:"MyTeslaError", originalError: errFromSomething});
 *     LEVEL    TIMESTAMP               APPLICATION_NAME            MESSAGE                             TYPE           FileName
 *     ERROR    Sept 23, 2015 3:30 PM   configurator-admin-tools    Error submitting order to MyTesla   MyTeslaError   fileName where error came from
 *
 *     ^note: Column headings would not be included in actual log, this is for reference
 */

// if logDestinationType == 'console', then we will use colors in logging
var colors = {};

var Logger = {

    LogLevels: {
        // Trace statements are typically overly verbose debugging statements
        // that should be removed after initial development
        TRACE : 6,
        // Debugging statements are helpful to log when you are trying to debug a specific issue
        DEBUG : 5,
        // General logging of transactions (CRUD operations)
        INFO  : 4,
        // When something happens that you should pay attention to, but is not a critical error
        WARN  : 3,
        // For logging errors that you throw in your code on purpose (missing request params, etc)
        // Also used to log errors thrown by other api's that you use in your code
        ERROR : 2,
        // When system goes down, or some unrecoverable error occurs
        FATAL : 1,
        // NO LOGGING
        NONE  : 0
    },

    //  TRACE, DEBUG, INFO, WARN
    infoLogFields : ["applicationName","message"],

    // ERROR, FATAL
    errorLogFields : ["applicationName","message","code", "fileName"],

    // note: maybe use colors if logDestinationType is console
    // https://www.npmjs.com/package/colors
    __logDestinationType: "file",

    // set this to WARN or ERROR in production
    __logLevel: 5, // this.LogLevels.DEBUG

    // name of application
    __applicationName: null,

    // onf of ["string", "object"]
    __format: "string",

    // convert arguments object to array or wrap in array
    toArray : function(args){

        var argType = typeof args;

        switch(argType){
            case 'string':
               return [args];
            case 'object':
                if(!args.length){
                    return [args];
                }
            // convert arguments object into array
            default:
                return Array.prototype.slice.call(args, 0);
        }


        return [];
    },

    /**
     * Note: Should I just use moment.js for this?
     * @returns {string}
     */
    getIsoDate: function(){

        var d = new Date();
        var ampm = d.getHours() < 12 ? "AM" : "PM";

        var minutes = d.getMinutes();
        var seconds = d.getSeconds();

        if(seconds < 10){
            seconds = "0" + seconds;
        }

        if(minutes < 10){
            minutes = "0" + minutes;
        }

        var formattedDate = d.getFullYear() + "-" + (d.getMonth() + 1) + "-" + d.getDate() + "  " + d.getHours() + ":" + d.getMinutes() + ":" + seconds;
        return formattedDate;
    },

    /**
     * Returns friendly level name given a level number
     * @param level {Enum(0,1,2,3,4,5,6)}
     * @returns {string}
     */
    getLevelName: function(level){
        for(var key in this.LogLevels){
            if(this.LogLevels[key] === level){
                return key;
            }
        }
    },

    /**
     * Writes log to console stdout or stderr by default
     * Will write to nohup.out and nohup.err if process started with nohup
     *
     * nohup forever someProcess > nohup.out 2> nohup.err
     *
     * @param  {[type]} level [description]
     * @param args {Array}
     */
    __log: function(level, args){

        args = this.toArray(args);

        // if this.__logLevel is set to a higher level than the incoming log level, ignore it
        // ignore any log calls that are empty
        if((level > this.__logLevel) || args.length === 0){
            return;
        }

        var timestamp = this.getIsoDate();
        var levelName = this.getLevelName(level);
        var logEntry = {
            levelName: levelName,
            timestamp: timestamp
        };

        if(this.__applicationName){
            logEntry.applicationName = this.__applicationName;
        }

        // in INFO & WARN level, there will be one argument and it will be a message string
        if(typeof args[0] === 'string'){
            logEntry.message = args[0];
        }
        else if(args.length === 1 && typeof args[0] === 'object'){
            // add props to logEntry
            for(var p in args[0]){
                logEntry[p] = args[0][p];
            }
        }

        if(args.length > 1){
            this.__writeLog(level, logEntry, args.slice(1));
        }
        else{
            this.__writeLog(level, logEntry);
        }

    },

    /**
     * Writes log (currently just stdout or file if stdout is directed to nohup.out )
     *
     * Eventually, we could plug in adapters here that would allow us to send logs to mongo
     * or some other logging system
     *
     * @param level
     * @param logEntry
     * @private
     */
    __writeLog: function(level, logEntry){

        switch(level){
            case this.LogLevels.DEBUG:
            case this.LogLevels.TRACE:

                console.log(this.__formatAsString(logEntry));
                var args = this.toArray(arguments);

                if(args.length > 1){
                    try{
                        console.log.apply(console, args.slice(1));
                    }
                    catch(e){
                        console.log('error writing to console')
                    }

                }
                break;
            case this.LogLevels.ERROR:
            case this.LogLevels.FATAL:
                console.error(this.__formatAsString(logEntry, "error"));
                break;
            default:
                // WARN, INFO
                console.log(this.__formatAsString(logEntry));
        }
    },

    /**
     * Format log entry as tab delimited string
     * @param obj
     * @param logType {String} ["log","error"]
     * @private
     */
    __formatAsString: function(obj, logType){

        logType = logType || 'log';

        var logEntry,
            colDelimiter = '\t',
            // default to info
            fields = this.infoLogFields;

        if(typeof obj === 'object'){

            // if we are logging to console
            // let's spice things up with some colors...
            var err = colors.red,
                nfo = colors.cyan,
                debug = colors.magenta,
                warn = colors.yellow,
                fmt = logType === 'error' ? err : nfo;

            switch(obj.levelName){
                case 'DEBUG':
                    fmt  = debug;
                    break;
                case 'WARN':
                    fmt  = warn;
                    break;
            }

            if(colors && this.__logDestinationType === 'console' && fmt){
                logEntry = fmt(obj.levelName) + colDelimiter + obj.timestamp + colDelimiter;
            }
            else{
                logEntry = obj.levelName + colDelimiter + obj.timestamp + colDelimiter;
            }


            if(logType === 'error'){
                fields = this.errorLogFields;
            }

            for(var i = 0, n =  fields.length; i < n; i++){

                var field = obj[fields[i]];

                if(field){

                    logEntry += field;

                    if(i < fields.length - 1){
                        logEntry += colDelimiter;
                    }

                }
            }
        }

        return logEntry;
    },

    /**
     * For logging developer info, used in dev servers and local development
     */
    debug: function(){
        this.__log(this.LogLevels.DEBUG, arguments);
    },

    /**
     * Same as info(), here for convenience
     * @return {[type]} [description]
     */
    log: function(){
        this.__log(this.LogLevels.INFO, arguments);
    },

    /**
     * For logging informational messages, like successful transactions, etc
     * @param errorMessaage
     */
    info: function(errorMessage){
        this.__log(this.LogLevels.INFO, [errorMessage]);
    },

    /**
     * For logging information messages that should be looked at,
     * pass through
     * @param errorMessaage
     * @param ... [allows optional additional arguments to be passed in for additional logging info ]
     */
    warn: function(errorMessage){
        this.__log(this.LogLevels.WARN, arguments);
    },

    /**
     * For logging handled errors
     */
    error: function(errorObject){
        this.__log(this.LogLevels.ERROR, errorObject);
    },

    /**
     * For logging server failures
     */
    fatal: function(errorObject){
        this.__log(this.LogLevels.FATAL, errorObject);
    },

    /**
     * Sets the logging level
     * @param {[type]} logLevel [description]
     */
    setLevel: function(logLevel){

        if(this.LogLevels[logLevel]){
            this.__logLevel = logLevel;
        }
        else{
            console.warn('setLogLevel', logLevel + ' is an invalid log level');
        }
    },

    /**
     * Set the destination of the log to 'console' or 'file' (defaults to 'file')
     * @param logType
     */
    setLogDestinationType: function(logDestinationType){
        this.__logDestinationType = logDestinationType;

        if(logDestinationType === "console"){
            colors = require('colors')
        }
    },

    /**
     * if set, will be part of log entry
     * @param applicationName
     */
    setApplicationName: function(applicationName){
        this.__applicationName = applicationName;
    }
};

module.exports = Logger;
