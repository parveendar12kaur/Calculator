var _ = require('lodash');

/**
 * Wrapper for error objects.
 *
 *  Purpose: To wrap errors in an interface for consistency.
 *  Will be used for logging and/or possibly to serialize errors for REST service error responses.
 *
 *  The idea here is that you would instantiate a ServiceError for:
 *
 *  - Explicitly thrown errors (bad input, invalid parameters, etc)
 *  - Unknown errors thrown by some other service or component (like endpoint was down, etc)
 *  - or even fatal errors that may/may not be recoverable but could be logged.
 *
 *  AND
 *
 *  It would always return an object that had the following fields (TBD):
 *
 *   name    [name or type of error like MissingParameter]
 *   message [Short description of why the error was thrown]
 *
 *   {
 *       name: "InvalidInput",
 *       message: "Cannot save order, invalid input"
 *   }
 *
 *   If we have access to them, we could also include fields like:
 *
 *   file    [name of file where error occurred]
 *   lineNum [the line where the error occurred]
 *   stack   [stack trace of the error] - could be used during logging if 'verbose' flag is set
 *
 *   NOTE: this is a work in progress, please give feedback
 *
 * @author Frank Young
 * @param props
 * @constructor
 */
function ServiceError(props) {

    // convert to object if string is passed in
    if (typeof props === 'string') {
        props = {message: props};
    }

    var error = Error.call(this, props.message);

    // set error properties
    this.props = props;
    this.name = props.name || 'ServiceError';
    this.message = props.message || error.message;
    this.stack = error.stack;

    this.code = getCode(props);
    this.originalError = normalizeError(props.error || props.originalError) || null;

    /**
     * Return simple js object
     * @returns {{name: *, message: *, code: *}}
     */
    this.toJSON = function () {
        return _.omit({
            name: this.name,
            message: this.message,
            code: this.code,
            error: this.originalError
        }, function (v) {
            return _.isUndefined(v) || _.isNull(v);
        });
    };

    /**
     *
     * @returns {string}
     */
    function getFileName() {
        return "";
    }

    function getLineNum() {
        return "";
    }


    /**
     * Returns error code
     * @returns {String}
     */
    function getCode(props) {

        var code;

        if (props.code) {
            code = props.code;
        }
        else if (props.originalError) {
            code = props.originalError.status ||  props.originalError.code;
        }

        return code;
    };

    /**
     * Return normalized error object from various types of errors
     * @param errObject
     * @returns {{name: *, message: *}}
     */
    function normalizeError(errObject) {

        var normalizedError;

        if (errObject) {
            normalizedError = {};
            for (var p in errObject) {
                // todo, actually do some normalization
                normalizedError[p] = errObject[p];
            }
        }

        // TODO - figure out how to get fileName and lineNum from stack trace
        // look into:
        // https://github.com/baryon/tracer
        // https://github.com/felixge/node-stack-trace

        return normalizedError;
    }
};

/**
 * Format this error as string for logging
 * @param err
 * @returns {string}
 */
/*
 TODO: figure out how to get line and file from error
 ServiceError.prototype.formatAsString = function(err){

 var errorString = '<' + this.name + '>' + '\t';

 if(this.file){
 errorString += '' + this.file + ':' + this.line;
 }

 errorString += '(' + this.message + ')';

 return errorString;
 };
 */

ServiceError.prototype = Object.create(Error.prototype);
ServiceError.prototype.constructor = ServiceError;

ServiceError.types = {
    ServiceError: 'ServiceError',
    InvalidParameterValue: 'InvalidParameterValue',
    UnknownParameter: 'UnknownParameter',
    MissingParameter: 'MissingParameter'
};

module.exports = ServiceError;
