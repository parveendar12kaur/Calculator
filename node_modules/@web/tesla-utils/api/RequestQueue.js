"use strict";

var request = require('superagent');
var defaultAcceptType = 'application/json';
var defaultContentType = 'application/x-www-form-urlencoded';
var defaultTimeout = 1000 * 10; // 10 second default timeout

/**
 * Simple queue mechanism for handling arrays of REST or SOAP requests
 *
 * Note: Hmmm... somehow I totally forgot about the async library
 * which is far more powerful than this, doh!  But this might be useful when you just need something simple.
 * https://github.com/caolan/async
 *
 * @note: Currently only supports running a single queue at at time
 *        if you need to fire off multiple queued requests at the same time, create another instance of RequestQueue
 *        
 * @requires superagent (for GET and POST requests)
 * @author Frank Young
 */
function RequestQueue(){

	var __pendingRequests = [];
    var __eventBindings = {};    
	var __cancelRequest = false;
    var __currentRequest = null;

    /**
     * Makes GET request
     * @private
     * @param  {Object}   req
     * @param  {Function} callback
     */
	function __get(req, callback){

        if(__cancelRequest){
		    return;
		}

        __currentRequest = request.get(req.url)
            .timeout(req.timeout   || defaultTimeout)
            .accept(req.acceptType || defaultAcceptType)
            .query(req.data)
            .end(callback);
	}

    /**
     * Makes POST request
     * @private
     * @param  {Object} req  POST request object
     * @param  {Function} callback
     */
	function __post(req, callback){

        if(__cancelRequest){
		    return;
		}		

        __currentRequest = request.post(req.url)
            .timeout(req.timeout   || defaultTimeout)
            .accept(req.acceptType || defaultAcceptType)
            .send(req.data)
            .set('Content-Type', req.contentType || defaultContentType)            
            .end(callback);
	}

    /**
     * Makes SOAP request
     * @private
     * @param  {Function} soapMethod - soap client method to pass request to
     * @param  {Object} soapRequest JSON object that 
     */
    function __soap(soapMethod, soapRequest, callback){

        if(__cancelRequest){
            return;
        }

        soapMethod(soapRequest, function(err, result){
             callback(err, result);
        });
    }    

    /**
     * Fires event off to listeners (if present)
     * @param  {String} eventName
     */
	function __fire(eventName, data){

		var evt = __eventBindings[eventName];
        if(evt && typeof evt.fn === 'function'){
        	evt.fn.apply(null, [{
        		data: data,
        		numPendingRequests: __pendingRequests.length
        	}]);
        }
	}


	return {

        /**
         * Return any pending requests
         * @return {Array}
         */
		getPendingRequests: function(){

            return __pendingRequests;
		},

        /**
         * Resets queue to empty array
         * @chainable
         */
		reset: function(){

            __pendingRequests = [];
            __cancelRequest = false;

            return this;
		},

        /**
         * Cancels queue (will not continue with other requests)
         * @chainable
         */
		cancel: function(){

            __cancelRequest = this;

            if(__currentRequest && typeof __currentRequest.abort === 'function'){
                __currentRequest.abort();
            }
		},
 
        /**
         * Queue up a series of GET requests
         * @param  {Array}   requests  Array of GET request objects
         * @param  {Function} callback -- Function to call when all requests have returned
         * @chainable
         */
		get: function(requests, callback){

            var responses = [];

            __pendingRequests = requests;

            function onComplete(err, res){

				responses.push(res);         

                if(!err && __pendingRequests.length){
                    __fire("progress", res);                    
                    __get(__pendingRequests.shift(), onComplete);
                }
                else{
                	callback(err, responses);
                }
            }

			__get(__pendingRequests.shift(), onComplete);

            return this;
		},

        /**
         * Queue up a series of POST requests
         * @param  {Array}   requests  Array of POST request objects
         * @param  {Function} callback -- Function to call when all requests have returned
         * @chainable         
         */
		post: function(requests, callback){

            __pendingRequests = requests;

            var responses = [];

            function onComplete(err, res){

				responses.push(res);

                if(!err && __pendingRequests.length){
                    __fire("progress", res);                    
                    __post(__pendingRequests.shift(), onComplete);
                }
                else{
                	callback(err, responses);
                }
            }

			__post(__pendingRequests.shift(), onComplete);

            return this;
		},

        /**
         * Queues up soap requests and fires callback method when all have completed
         * 
         * @see (soap package for nodejs) https://www.npmjs.com/package/soap
         * @param  {Function}   soapMethod   [description]
         * @param  {Array}   soapRequests [description]
         * @param  {Function} callback     [description]
         * @chainable
         */
        soap: function(soapMethod, soapRequests, callback){

            __pendingRequests = soapRequests;

            var responses = [];

            function onComplete(err, res){

                responses.push(res);

                if(!err && __pendingRequests.length){
                    __fire("progress", res);                    
                    __soap(soapMethod, __pendingRequests.shift(), onComplete);
                }
                else{
                    callback(err, responses);
                }
            }

            __soap(soapMethod, __pendingRequests.shift(), onComplete);

            return this;           
        },

        /**
         * Add event listener (only 'progress' supported right now)
         */
		on: function(evt, callback){
			if(!__eventBindings[evt]){
				__eventBindings[evt] = {
					fn: callback
				}
			}  
		}

	};

}


module.exports = RequestQueue;